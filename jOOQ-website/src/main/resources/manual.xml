<?xml version="1.0" encoding="UTF-8"?>
<manual>
	<section id="manual">
		<title>The jOOQ User Manual</title>
		<slogan>
			Learn about jOOQ using its single or multi-paged manuals
		</slogan>
		<content>
			<h3>Single-paged manuals</h3>
			<p>Coming soon in the manuals section of the jOOQ website:</p>
			<ul>
				<li>A single-paged HTML manual</li>
				<li>A downloadable PDF manual</li>
			</ul>
			<h3>The multi-paged manual</h3>
			<p>This manual is divided into four main sections:</p>
			<ul>
				<li>
					<reference id="JOOQ"/>
					<p>
						See these chapters for an overview of the jOOQ internal architecture
						and all types that are involved with jOOQ's query creation and
						execution. This is the important part for you, also, if you wish to
						extend jOOQ
					</p>
				</li>
				<li>
					<reference id="META"/>
					<p>
						See these chapters to understand how you can use jOOQ as a source code
						generator, and what type of artefacts are generated by jOOQ
					</p>
				</li>
				<li>
					<reference id="DSL"/>
					<p>
						See these chapters to learn about how to use jOOQ in every day's work. The
						jOOQ DSL is the main way to create and execute jOOQ queries almost as
						if SQL was embedded in Java directly
					</p>
				</li>
				<li>
					<reference id="ADVANCED"/>
					<p>
						Some advanced topics including not-everyday functionality
					</p>
				</li>
			</ul>
		</content>
		
		
		<sections>
			<section id="JOOQ">
				<title>jOOQ classes and their usage</title>
				<slogan>
					In these sections, you will learn about how to use jOOQ object
					factories and the jOOQ object oriented query model, to express
					your SQL in jOOQ
				</slogan>
				<content>
					<h2>Overview</h2>
					<p>jOOQ essentially has two packages:</p>
					<ul>
						<li>org.jooq: the jOOQ API. Here you will find interfaces for all
							SQL concepts
						</li>
						<li>org.jooq.impl: the jOOQ implementation and factories. Most
							implementation classes are package private, you can only access
							them using the <reference id="Factory" title="org.jooq.impl.Factory"/> 
						</li>
					</ul>
					<p>
						This section is about the main jOOQ classes and the global
						architecture. Most of the time, however, you will be using the
						<reference id="DSL" />
						in order to create queries
						the way you're used to in SQL
					</p>
				</content>
				
				
				<sections>
					<section id="ExampleDatabase">
						<title>The example database</title>
						<slogan>
							For the examples in this manual, the same database will always be
							referred to. It essentially consists of these entities created using
							the Oracle dialect
						</slogan>
						<content>
							<h2>Example CREATE TABLE statements</h2>
							<pre class="prettyprint lang-sql">
CREATE TABLE t_language (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  cd CHAR(2) NOT NULL,
  description VARCHAR2(50)
)

CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50) NOT NULL,
  date_of_birth DATE,
  year_of_birth NUMBER(7)
)

CREATE TABLE t_book (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  author_id NUMBER(7) NOT NULL,
  title VARCHAR2(400) NOT NULL,
  published_in NUMBER(7) NOT NULL,
  language_id NUMBER(7) NOT NULL,
  FOREIGN KEY (AUTHOR_ID) REFERENCES T_AUTHOR(ID),
  FOREIGN KEY (LANGUAGE_ID) REFERENCES T_LANGUAGE(ID)
)

CREATE TABLE t_book_store (
  name VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE t_book_to_book_store (
  book_store_name VARCHAR2(400) NOT NULL,
  book_id INTEGER NOT NULL,
  stock INTEGER,
  PRIMARY KEY(book_store_name, book_id),
  CONSTRAINT b2bs_book_store_id
    FOREIGN KEY (book_store_name)
    REFERENCES t_book_store (name)
    ON DELETE CASCADE,
  CONSTRAINT b2bs_book_id
    FOREIGN KEY (book_id)
    REFERENCES t_book (id)
    ON DELETE CASCADE
)							
							</pre>
							<p>
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc),
								stored procedures and packages are introduced for specific examples
							</p>
						</content>
					</section>
					
					
					<section id="Factory">
						<title>The Factory class</title>
						<slogan>
							jOOQ hides most implementation facts from you by letting you
							use the jOOQ Factory as a single entry point to all of the jOOQ API.
							This way, you can discover all of the API using syntax auto-completion, for
							instance. 
						</slogan>
						<content>
							<h2>The Factory and the jOOQ API</h2>
							<p>
								jOOQ exposes a lot of interfaces and hides most implementation facts 
								from client code. The reasons for this are: 
							</p>
							<ul>
								<li>Interface-driven design. This allows for modelling queries in a fluent API most efficiently</li>
								<li>Reduction of complexity for client code.</li>
								<li>API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</li>
							</ul>
							<p>
								The <reference class="org.jooq.impl.Factory"/> 
								class is the main class from where you will create all jOOQ objects. 
								The Factory implements <reference class="org.jooq.Configuration"/> 
								and needs to be instanciated with the Configuration's properties: 
							</p>
							<ul>
								<li><reference class="org.jooq.SQLDialect"/> : 
								The dialect of your database. This may be any of the currently
								supported database types</li>
								<li><reference class="java.sql.Connection"/> : 
								A JDBC Connection that will be re-used for the whole
    							lifecycle of your Factory</li>
    							<li><reference class="org.jooq.SchemaMapping"/> : 
    							An optional mapping of schemata. Check out the 
    							<reference id="SchemaMapping" title="SchemaMapping"/>
    							page for details</li> 
							</ul>
							<p>If you are planning on using several RDBMS (= SQLDialects) or
								several distinct JDBC Connections in your software, this will mean
								that you have to create a new Factory every time. </p>
							
							<h3>Factory subclasses</h3>
							<p>
								There are a couple of subclasses for the general Factory. Each SQL
								dialect has its own dialect-specific factory. For instance, if you're
								only using the MySQL dialect, you can choose to create a new Factory
								using any of the following types: 
							</p>
							<pre class="prettyprint lang-java">
// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);
							</pre>
							<p>
								The advantage of using a dialect-specific Factory lies in the fact,
								that you have access to more proprietary RDMBS functionality. This may
								include: 
							</p>
							<ul>
								<li>Oracle's <reference id="CONNECTBY" title="CONNECT BY"/>
								    pseudo columns and functions</li>
    							<li>MySQL's encryption functions</li>
    							<li>PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</li>
							</ul>
							<p>
								Another type of Factory subclasses are each generated schema's
								factories. If you generate your schema TEST, then you will have access
								to a TestFactory. This will be useful in the future, when access to
								schema artefacts will be unified. Currently, this has no use. 
							</p>
							
							<h3>Potential problems</h3>
							<p>
								The jOOQ Factory expects its underlying
								<reference class="java.sql.Connection" />
								to be <strong>open and ready</strong>
								for
								<reference class="java.sql.PreparedStatement" />
								creation. You are responsible yourself for the
								lifecycle dependency between Factory and Connection. This means: 
							</p>
							<ul>
								<li>jOOQ will never close the Connection.</li>
								<li>jOOQ will never commit or rollback on the Connection 
									(Except for CSV-imports, if explicitly configured in the <reference id="Import" title="Import API"/>)</li>
								<li>jOOQ will never start any transactions.</li>
								<li>
									jOOQ does not know the concept of a session as for instance
									<a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/architecture.html#architecture-current-session">Hibernate</a>
								</li>
								<li>jOOQ does not know the concept of a second-level cache. SQL is
									executed directly on the underlying RDBMS.</li>
								<li>jOOQ does not make assumptions about the origin of the Connection.
									If it is container managed, that is fine.</li> 
							</ul>
							<p>
								So if you want your queries to run in separate transactions, if you
								want to roll back a transactions, if you want to close a Connection and
								return it to your container, you will have to take care of that
								yourself. jOOQ's Factory will always expect its Connection to be in a
								ready state for creating new PreparedStatements. If it is not, you have
								to create a new Factory. 
							</p>
							<p>
								Please keep in mind that many jOOQ objects will reference your Factory
								for their whole lifecycle. This is especially interesting, when dealing
								with <reference id="UpdatableRecord" title="Updatable Records"/>,
								that can perform CRUD operations on the
								Factory's underlying Connection.
							</p>
						</content>
					</section>
					
					
					<section id="Table">
						<title>Tables and Fields</title>
						<slogan>
							Tables and their Fields are probably the most important objects in
							jOOQ. Tables represent any entity in your underlying RDBMS, that holds
							data for selection, insertion, updates, and deletion. In other words,
							views are also considered tables by jOOQ. 
						</slogan>
						<content>
							<h2>The Table</h2>
							<p>The formal definition of a <reference class="org.jooq.Table"/> starts with </p>
							<pre class="prettyprint lang-java">public interface Table&lt;R extends Record&gt; // [...]</pre>
							<p>
								This means that every table is associated with a subtype of the
								<reference class="org.jooq.Record" />
								class (see also
								<reference id="Result" title="Results and Records" />
								). For anonymous or ad-hoc tables,
								&lt;R&gt; will always bind to Record itself. 
							</p>
							<p>
								Unlike in the
								<a href="http://download.oracle.com/javaee/6/tutorial/doc/gjitv.html"
									title="Tutorial about JPA CriteriaQuery">JPA CriteriaQuery API</a>,
								this generic type
								&lt;R&gt;
								is not given so much importance as far as
								type-safety is concerned.
								SQL itself is inherently type-unsafe. But then
								again, you have
								incredible flexibility of creating anonymous or ad-hoc
								types and
								reusing them from
								<reference id="NESTED" title="NESTED SELECT statements" />
								or from many other
								use-cases. If
								&lt;R&gt; would play a role as important
								as in JPA, jOOQ
								would suffer from
								the same verbosity, or inflexibility
								that JPA
								CriteriaQueries may
								have. 
							</p>
							
							<h2>The Field</h2>
							<p>The formal definition of a Field starts with </p>
							<pre class="prettyprint lang-java">public interface Field&lt;T&gt; // [...]</pre>
							<p>
								Fields are generically parameterised with a Java type
								&lt;T&gt;
								that reflects the closest match to the RDMBS's underlying datatype for that
								field. For instance, if you have a VARCHAR2 type Field in Oracle,
								&lt;T&gt;
								would bind to
								<reference class="java.lang.String" />
								for that Field in jOOQ. Oracle's NUMBER(7) would
								let
								&lt;T&gt;
								bind to
								<reference class="java.lang.Integer" />,
								etc. This generic type is useful for two purposes:
							</p>
							<ul>
								<li>It allows you to write type safe queries. For instance, you cannot
									compare Field
									&lt;String&gt;
									with Field
									&lt;Integer&gt;</li>
						
								<li>It
									allows you to fetch correctly cast and converted values from
									your database result set. This is especially useful when &lt;T&gt; binds
									to
									advanced data types, such as
									<reference id="UDT" title="UDT's, ARRAY or ENUM types" />
									, where jOOQ
									does the difficult non-standardised JDBC data type conversions for you.
								</li>
							</ul> 
							
							<h2>Fields and tables put into action</h2>
							<p>The Field itself is a very broad concept. Other tools, or databases
								refer to it as expression or column. When you just want to </p>
								
							<pre class="prettyprint lang-sql">SELECT 1 FROM DUAL</pre>
							<p>
								Then 1 is considered a Field or more explicitly, a
								<reference class="org.jooq.impl.Constant" />, 
								which implements Field, and DUAL is considered a Table or more explicitly 
								<reference class="org.jooq.impl.Dual"/>, which implements Table
							</p>
							<p>
								More advanced uses become clear quickly, when you do things like 
							</p>
							<pre class="prettyprint lang-sql">SELECT 1 + 1 FROM DUAL</pre>
							<p>
								Where 1 + 1 itself is a Field or more explicitly, an 
								<reference class="org.jooq.impl.Expression"/> 
								joining two Constants together. 
							</p>
							<p>
								See some details about how to create these queries in the
								<reference id="Query" title="Query section"/> of the manual 
							</p>
							
							<h2>TableFields</h2>
							<p>
								A specific type of field is the
								<reference class="org.jooq.TableField" />,
								which represents a physical
								Field in a physical Table. Both the
								TableField and its referenced Table
								know each other. The physical aspect
								of their nature is represented in
								jOOQ by
								<reference id="TABLE" title="meta model code generation" />,
								where every entity in your database
								schema will be generated into a
								corresponding Java class.
							</p>
							<p>
								TableFields join both &lt;R&gt; and &lt;T&gt; generic parameters into their specification: 
							</p>
							<pre class="prettyprint lang-java">public interface TableField&lt;R extends Record, T&gt; // [...]</pre>
							<p>
								This can be used for additional type safety in the future, or by client code.
							</p>
						</content>
					</section>
					
					
					<section id="Result">
						<title>Results and Records</title>
					</section>
					<section id="UpdatableRecord">
						<title>Updatable Records</title>
					</section>
					<section id="Query">
						<title>Query and its subtypes</title>
					</section>
					<section id="ResultQuery">
						<title>ResultQuery and various ways of fetching data</title>
					</section>
					<section id="QueryPart">
						<title>QueryParts and the global architecture</title>
					</section>
					<section id="Serializability">
						<title>Serializability of QueryParts and Results</title>
					</section>
					<section id="Extend">
						<title>Extend jOOQ types with custom implementations</title>
					</section>
				</sections>
			</section>
			<section id="META">
				<title>Meta model code generation</title>
				<sections>
					<section id="Configuration">
						<title>Configuration and setup</title>
					</section>
					<section id="SCHEMA">
						<title>Schemata</title>
					</section>
					<section id="TABLE">
						<title>Tables and views and their corresponding records</title>
					</section>
					<section id="PROCEDURE">
						<title>Procedures and packages</title>
					</section>
					<section id="UDT">
						<title>UDT's including ARRAY and ENUM types</title>
					</section>
					<section id="SEQUENCE">
						<title>Sequences</title>
					</section>
				</sections>
			</section>
			<section id="DSL">
				<title>DSL or fluent API</title>
				<sections>
					<section id="SELECT">
						<title>Complete SELECT syntax</title>
					</section>
					<section id="CONDITION">
						<title>Conditions</title>
					</section>
					<section id="ALIAS">
						<title>Aliased tables and fields</title>
					</section>
					<section id="IN">
						<title>Nested select statements using the IN operator</title>
					</section>
					<section id="EXISTS">
						<title>Nested select statements using the EXISTS operator</title>
					</section>
					<section id="NESTED">
						<title>Other types of nested selects</title>
					</section>
					<section id="UNION">
						<title>UNION and other set operations</title>
					</section>
					<section id="FUNCTIONS">
						<title>Functions, aggregate operators, and window functions</title>
					</section>
					<section id="PROCEDURES">
						<title>Stored procedures and functions</title>
					</section>
					<section id="ARITHMETIC">
						<title>Arithmetic operations</title>
					</section>
					<section id="CASE">
						<title>The CASE clause</title>
					</section>
					<section id="CAST">
						<title>Type casting</title>
					</section>
					<section id="SQL">
						<title>When it's just much easier: Plain SQL</title>
					</section>
				</sections>
			</section>
			<section id="ADVANCED">
				<title>Advanced topics</title>
				<sections>
					<section id="MasterData">
						<title>Master data generation</title>
					</section>
					<section id="SchemaMapping">
						<title>Mapping generated schemata and tables to productive environments</title>
					</section>
					<section id="OracleHints">
						<title>Adding Oracle hints to queries</title>
					</section>
					<section id="CONNECTBY">
						<title>The Oracle CONNECT BY clause for hierarchical queries</title>
					</section>
					<section id="Export">
						<title>Exporting data to XML, CSV, JSON, HTML, Text</title>
					</section>
					<section id="Import">
						<title>Importing data from XML, CSV</title>
					</section>
				</sections>
			</section>
		</sections>
	</section>
</manual>