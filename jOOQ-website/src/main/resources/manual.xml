<?xml version="1.0" encoding="UTF-8"?>
<manual>
	<section id="manual">
		<title>The jOOQ User Manual</title>
		<slogan>
			Learn about jOOQ using its single or multi-paged manuals
		</slogan>
		<content>
			<h3>Single-paged manuals</h3>
			<p>Coming soon in the manuals section of the jOOQ website:</p>
			<ul>
				<li>A single-paged HTML manual</li>
				<li>A downloadable PDF manual</li>
			</ul>
			<h3>The multi-paged manual</h3>
			<p>This manual is divided into four main sections:</p>
			<ul>
				<li>
					<reference id="JOOQ"/>
					<p>
						See these chapters for an overview of the jOOQ internal architecture
						and all types that are involved with jOOQ's query creation and
						execution. This is the important part for you, also, if you wish to
						extend jOOQ
					</p>
				</li>
				<li>
					<reference id="META"/>
					<p>
						See these chapters to understand how you can use jOOQ as a source code
						generator, and what type of artefacts are generated by jOOQ
					</p>
				</li>
				<li>
					<reference id="DSL"/>
					<p>
						See these chapters to learn about how to use jOOQ in every day's work. The
						jOOQ DSL is the main way to create and execute jOOQ queries almost as
						if SQL was embedded in Java directly
					</p>
				</li>
				<li>
					<reference id="ADVANCED"/>
					<p>
						Some advanced topics including not-everyday functionality
					</p>
				</li>
			</ul>
		</content>
		
		
		<sections>
			<section id="JOOQ">
				<title>jOOQ classes and their usage</title>
				<slogan>
					In these sections, you will learn about how to use jOOQ object
					factories and the jOOQ object oriented query model, to express
					your SQL in jOOQ
				</slogan>
				<content>
					<h2>Overview</h2>
					<p>jOOQ essentially has two packages:</p>
					<ul>
						<li>org.jooq: the jOOQ API. Here you will find interfaces for all
							SQL concepts
						</li>
						<li>org.jooq.impl: the jOOQ implementation and factories. Most
							implementation classes are package private, you can only access
							them using the <reference id="Factory" title="org.jooq.impl.Factory"/> 
						</li>
					</ul>
					<p>
						This section is about the main jOOQ classes and the global
						architecture. Most of the time, however, you will be using the
						<reference id="DSL" />
						in order to create queries
						the way you're used to in SQL
					</p>
				</content>
				
				
				<sections>
					<section id="ExampleDatabase">
						<title>The example database</title>
						<slogan>
							For the examples in this manual, the same database will always be
							referred to. It essentially consists of these entities created using
							the Oracle dialect
						</slogan>
						<content>
							<h2>Example CREATE TABLE statements</h2>
							<pre class="prettyprint lang-sql">
CREATE TABLE t_language (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  cd CHAR(2) NOT NULL,
  description VARCHAR2(50)
)

CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50) NOT NULL,
  date_of_birth DATE,
  year_of_birth NUMBER(7)
)

CREATE TABLE t_book (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  author_id NUMBER(7) NOT NULL,
  title VARCHAR2(400) NOT NULL,
  published_in NUMBER(7) NOT NULL,
  language_id NUMBER(7) NOT NULL,
  FOREIGN KEY (AUTHOR_ID) REFERENCES T_AUTHOR(ID),
  FOREIGN KEY (LANGUAGE_ID) REFERENCES T_LANGUAGE(ID)
)

CREATE TABLE t_book_store (
  name VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE t_book_to_book_store (
  book_store_name VARCHAR2(400) NOT NULL,
  book_id INTEGER NOT NULL,
  stock INTEGER,
  PRIMARY KEY(book_store_name, book_id),
  CONSTRAINT b2bs_book_store_id
    FOREIGN KEY (book_store_name)
    REFERENCES t_book_store (name)
    ON DELETE CASCADE,
  CONSTRAINT b2bs_book_id
    FOREIGN KEY (book_id)
    REFERENCES t_book (id)
    ON DELETE CASCADE
)							
							</pre>
							<p>
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc),
								stored procedures and packages are introduced for specific examples
							</p>
						</content>
					</section>
					
					
					<section id="Factory">
						<title>The Factory class</title>
						<slogan>
							jOOQ hides most implementation facts from you by letting you
							use the jOOQ Factory as a single entry point to all of the jOOQ API.
							This way, you can discover all of the API using syntax auto-completion, for
							instance. 
						</slogan>
						<content>
							<h2>The Factory and the jOOQ API</h2>
							<p>
								jOOQ exposes a lot of interfaces and hides most implementation facts 
								from client code. The reasons for this are: 
							</p>
							<ul>
								<li>Interface-driven design. This allows for modelling queries in a fluent API most efficiently</li>
								<li>Reduction of complexity for client code.</li>
								<li>API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</li>
							</ul>
							<p>
								The <reference class="org.jooq.impl.Factory"/> 
								class is the main class from where you will create all jOOQ objects. 
								The Factory implements <reference class="org.jooq.Configuration"/> 
								and needs to be instanciated with the Configuration's properties: 
							</p>
							<ul>
								<li><reference class="org.jooq.SQLDialect"/> : 
								The dialect of your database. This may be any of the currently
								supported database types</li>
								<li><reference class="java.sql.Connection"/> : 
								A JDBC Connection that will be re-used for the whole
    							lifecycle of your Factory</li>
    							<li><reference class="org.jooq.SchemaMapping"/> : 
    							An optional mapping of schemata. Check out the 
    							<reference id="SchemaMapping" title="SchemaMapping"/>
    							page for details</li> 
							</ul>
							<p>If you are planning on using several RDBMS (= SQLDialects) or
								several distinct JDBC Connections in your software, this will mean
								that you have to create a new Factory every time. </p>
							
							<h3>Factory subclasses</h3>
							<p>
								There are a couple of subclasses for the general Factory. Each SQL
								dialect has its own dialect-specific factory. For instance, if you're
								only using the MySQL dialect, you can choose to create a new Factory
								using any of the following types: 
							</p>
							<pre class="prettyprint lang-java">
// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);
							</pre>
							<p>
								The advantage of using a dialect-specific Factory lies in the fact,
								that you have access to more proprietary RDMBS functionality. This may
								include: 
							</p>
							<ul>
								<li>Oracle's <reference id="CONNECTBY" title="CONNECT BY"/>
								    pseudo columns and functions</li>
    							<li>MySQL's encryption functions</li>
    							<li>PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</li>
							</ul>
							<p>
								Another type of Factory subclasses are each generated schema's
								factories. If you generate your schema TEST, then you will have access
								to a TestFactory. This will be useful in the future, when access to
								schema artefacts will be unified. Currently, this has no use. 
							</p>
							
							<h3>Potential problems</h3>
							<p>
								The jOOQ Factory expects its underlying
								<reference class="java.sql.Connection" />
								to be <strong>open and ready</strong>
								for
								<reference class="java.sql.PreparedStatement" />
								creation. You are responsible yourself for the
								lifecycle dependency between Factory and Connection. This means: 
							</p>
							<ul>
								<li>jOOQ will never close the Connection.</li>
								<li>jOOQ will never commit or rollback on the Connection 
									(Except for CSV-imports, if explicitly configured in the <reference id="Import" title="Import API"/>)</li>
								<li>jOOQ will never start any transactions.</li>
								<li>
									jOOQ does not know the concept of a session as for instance
									<a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/architecture.html#architecture-current-session">Hibernate</a>
								</li>
								<li>jOOQ does not know the concept of a second-level cache. SQL is
									executed directly on the underlying RDBMS.</li>
								<li>jOOQ does not make assumptions about the origin of the Connection.
									If it is container managed, that is fine.</li> 
							</ul>
							<p>
								So if you want your queries to run in separate transactions, if you
								want to roll back a transactions, if you want to close a Connection and
								return it to your container, you will have to take care of that
								yourself. jOOQ's Factory will always expect its Connection to be in a
								ready state for creating new PreparedStatements. If it is not, you have
								to create a new Factory. 
							</p>
							<p>
								Please keep in mind that many jOOQ objects will reference your Factory
								for their whole lifecycle. This is especially interesting, when dealing
								with <reference id="UpdatableRecord" title="Updatable Records"/>,
								that can perform CRUD operations on the
								Factory's underlying Connection.
							</p>
						</content>
					</section>
					
					
					<section id="Table">
						<title>Tables and Fields</title>
						<slogan>
							Tables and their Fields are probably the most important objects in
							jOOQ. Tables represent any entity in your underlying RDBMS, that holds
							data for selection, insertion, updates, and deletion. In other words,
							views are also considered tables by jOOQ. 
						</slogan>
						<content>
							<h2>The Table</h2>
							<p>The formal definition of a <reference class="org.jooq.Table"/> starts with </p>
							<pre class="prettyprint lang-java">public interface Table&lt;R extends Record&gt; // [...]</pre>
							<p>
								This means that every table is associated with a subtype of the
								<reference class="org.jooq.Record" />
								class (see also
								<reference id="Result" title="Results and Records" />
								). For anonymous or ad-hoc tables,
								&lt;R&gt; will always bind to Record itself. 
							</p>
							<p>
								Unlike in the
								<a href="http://download.oracle.com/javaee/6/tutorial/doc/gjitv.html"
									title="Tutorial about JPA CriteriaQuery">JPA CriteriaQuery API</a>,
								this generic type
								&lt;R&gt;
								is not given so much importance as far as
								type-safety is concerned.
								SQL itself is inherently type-unsafe. But then
								again, you have
								incredible flexibility of creating anonymous or ad-hoc
								types and
								reusing them from
								<reference id="NESTED" title="NESTED SELECT statements" />
								or from many other
								use-cases. If
								&lt;R&gt; would play a role as important
								as in JPA, jOOQ
								would suffer from
								the same verbosity, or inflexibility
								that JPA
								CriteriaQueries may
								have. 
							</p>
							
							<h2>The Field</h2>
							<p>The formal definition of a Field starts with </p>
							<pre class="prettyprint lang-java">public interface Field&lt;T&gt; // [...]</pre>
							<p>
								Fields are generically parameterised with a Java type
								&lt;T&gt;
								that reflects the closest match to the RDMBS's underlying datatype for that
								field. For instance, if you have a VARCHAR2 type Field in Oracle,
								&lt;T&gt;
								would bind to
								<reference class="java.lang.String" />
								for that Field in jOOQ. Oracle's NUMBER(7) would
								let
								&lt;T&gt;
								bind to
								<reference class="java.lang.Integer" />,
								etc. This generic type is useful for two purposes:
							</p>
							<ul>
								<li>It allows you to write type safe queries. For instance, you cannot
									compare Field
									&lt;String&gt;
									with Field
									&lt;Integer&gt;</li>
						
								<li>It
									allows you to fetch correctly cast and converted values from
									your database result set. This is especially useful when &lt;T&gt; binds
									to
									advanced data types, such as
									<reference id="UDT" title="UDT's, ARRAY or ENUM types" />
									, where jOOQ
									does the difficult non-standardised JDBC data type conversions for you.
								</li>
							</ul> 
							
							<h2>Fields and tables put into action</h2>
							<p>The Field itself is a very broad concept. Other tools, or databases
								refer to it as expression or column. When you just want to </p>
								
							<pre class="prettyprint lang-sql">SELECT 1 FROM DUAL</pre>
							<p>
								Then 1 is considered a Field or more explicitly, a
								<reference class="org.jooq.impl.Constant" />, 
								which implements Field, and DUAL is considered a Table or more explicitly 
								<reference class="org.jooq.impl.Dual"/>, which implements Table
							</p>
							<p>
								More advanced uses become clear quickly, when you do things like 
							</p>
							<pre class="prettyprint lang-sql">SELECT 1 + 1 FROM DUAL</pre>
							<p>
								Where 1 + 1 itself is a Field or more explicitly, an 
								<reference class="org.jooq.impl.Expression"/> 
								joining two Constants together. 
							</p>
							<p>
								See some details about how to create these queries in the
								<reference id="Query" title="Query section"/> of the manual 
							</p>
							
							<h2>TableFields</h2>
							<p>
								A specific type of field is the
								<reference class="org.jooq.TableField" />,
								which represents a physical
								Field in a physical Table. Both the
								TableField and its referenced Table
								know each other. The physical aspect
								of their nature is represented in
								jOOQ by
								<reference id="TABLE" title="meta model code generation" />,
								where every entity in your database
								schema will be generated into a
								corresponding Java class.
							</p>
							<p>
								TableFields join both &lt;R&gt; and &lt;T&gt; generic parameters into their specification: 
							</p>
							<pre class="prettyprint lang-java">public interface TableField&lt;R extends Record, T&gt; // [...]</pre>
							<p>
								This can be used for additional type safety in the future, or by client code.
							</p>
						</content>
					</section>
					
					
					<section id="Result">
						<title>Results and Records</title>
						<slogan>
							Results and their Records come into play, when SELECT statements are
							executed. There are various ways to fetch data from a jOOQ SELECT
							statement. Essentially, the query results are always provided in the
							Result API
						</slogan>
						<content>
							<h2>The Result</h2>
							<p>
								The
								<reference class="org.jooq.Result" title="Result" />&lt;R extends <reference class="org.jooq.Record" title="Record" />&gt;
								is essentially a wrapper for a List&lt;R extends Record&gt;
								providing
								many convenience methods for accessing single elements in
								the result
								set. Depending on the type of SELECT statement,
								&lt;R&gt; can be bound
								to a sub-type of Record, for instance to an
								<reference class="org.jooq.UpdatableRecord" />. 
								See the section on
								<reference id="UpdatableRecord" title="Updatable Records" />
								for further details. 
							</p>
							
							<h2>The Cursor</h2>
							<p>
								A similar object is the 
								<reference class="org.jooq.Cursor" title="Cursor"/>&lt;R extends Record&gt;. 
								Unlike the Result, the cursor has not fetched all data from the database yet. 
								This means, you save memory (and potentially speed), but you can only access 
								data sequentially and you have to keep a JDBC ResultSet alive. Cursors behave 
								very much like the <reference class="java.util.Iterator"/>, 
								by providing a very simple API: 
							</p>
							<pre class="prettyprint lang-java">
// Check whether there are any more records to be fetched
boolean hasNext() throws SQLException;

// Fetch the next record from the underlying JDBC ResultSet
R fetchOne() throws SQLException;

// Close the underlying JDBC ResultSet. Don't forget to call this, before disposing the Cursor.
void close() throws SQLException;</pre>

							<h2>The Record</h2>
							<p>
								The Record itself holds all the data from your selected tuple. If it is
								a <reference class="org.jooq.TableRecord"/>, then it corresponds exactly to the type of one of your
								physical tables in your database. But any anonymous or ad-hoc tuple can
								be represented by the plain Record. A record mainly provides access to
								its data and adds convenience methods for data type conversion. These
								are the main access ways: 
							</p>
							<pre class="prettyprint lang-java">
// If you can keep a reference of the selected field, then you can get the corresponding value type-safely
&lt;T&gt; T getValue(Field&lt;T&gt; field);

// If you know the name of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(String fieldName);

// If you know the index of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(int index);</pre>
							<p>
								In some cases, you will not be able to reference the selected Fields
								both when you create the SELECT statement and when you fetch data from
								Records. Then you might use field names or indexes, as with JDBC.
								However, of course, the type information will then be lost as well. If
								you know what type you want to get, you can always use the Record's
								convenience methods for type conversion, however. Some examples: 
							</p>
							<pre class="prettyprint lang-java">
// These methods will try to convert a value to a BigDecimal.
// This will work for all numeric types and for CHAR/VARCHAR types, if they contain numeric values:
BigDecimal getValueAsBigDecimal(String fieldName);
BigDecimal getValueAsBigDecimal(int fieldIndex);

// This method can perform arbitrary conversions
&lt;T&gt; T getValue(String fieldName, Class&lt;? extends T&gt; type);
&lt;T&gt; T getValue(int fieldIndex, Class&lt;? extends T&gt; type);</pre>
						</content>
					</section>
					
					
					<section id="UpdatableRecord">
						<title>Updatable Records</title>
						<slogan>
							UpdatableRecords are a specific subtype of TableRecord that have
							primary key information associated with them.
						</slogan>
						<content>
							<h2>CRUD Operations</h2>
							<p>As of jOOQ 1.5, the UpdatableRecord essentially contains three additional
							 methods <a href="http://de.wikipedia.org/wiki/CRUD">CRUD</a> 
							 (Create Read Update Delete) operations: </p>
							<pre class="prettyprint lang-java">
// Store any changes made to this record to the database.
// The record executes an INSERT if the PRIMARY KEY is NULL or has been changed. Otherwise, an UPDATE is performed.
int store();

// Deletes the record from the database.
int delete();

// Reflects changes made in the database to this Record
void refresh();</pre>
							<p>An example lifecycle of a book can be implemented as such:</p>
							<pre class="prettyprint lang-java">
// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.store();

// Update it with new values
book.setPublishedIn(2010);
book.store();

// Delete it
book.delete();</pre>
							<p>These operations are very simple utilities. They do not 
							reflect the functionality offered by <a href="http://www.hibernate.org/">Hibernate</a> 
							or other persistence managers. </p>
							
							<h2>Performing CRUD on non-updatable records</h2>
							<p>
								If the jOOQ code-generator cannot detect any PRIMARY KEY, or UNIQUE KEY
								on your tables, then the generated artefacts implement TableRecord,
								instead of UpdatableRecord. A TableRecord can perform the same CRUD
								operations as we have seen before, if you provide it with the necessary
								key fields. The API looks like this: 
							</p>
							
							<pre class="prettyprint lang-java">
// INSERT or UPDATE the record using the provided keys
int storeUsing(TableField&lt;R, ?&gt;... keys)

// DELETE a record using the provided keys
int deleteUsing(TableField&lt;R, ?&gt;... keys);

// Reflects changes made in the database to this Record
void refreshUsing(TableField&lt;R, ?&gt;... keys);</pre>
						
							<p>
								This is useful if your RDBMS does not support referential constraints (e.g. MySQL's 
								<a href="http://en.wikipedia.org/wiki/MyISAM">MyISAM</a>), or if you want to 
								store records to an unconstrained view. An example lifecycle of a book without 
								any keys can then be implemented as such: 
							</p>
							<pre class="prettyprint lang-lava">
// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.storeUsing(TBook.ID);

// Update it with new values
book.setPublishedIn(2010);
book.storeUsing(TBook.ID);

// Delete it
book.deleteUsing(TBook.ID);</pre>
						</content>
					</section>
					
					
					<section id="Query">
						<title>The Query and its various subtypes</title>
						<slogan>
							The Query type hierarchy is what you use to execute queries. It has the
							following subtypes for each kind of operation
						</slogan>
						<content>
							<h2>SELECT statements</h2>
							<p>
								There are essentially two ways of creating SELECT statements in jOOQ.
								For historical reasons, you can create 
								<reference class="org.jooq.SimpleSelectQuery"/> or 
								<reference class="org.jooq.SelectQuery"/>
								objects and add additional query clauses, such as 
								<reference class="org.jooq.Condition" title="Conditions"/> or
								<reference class="org.jooq.SortField" title="SortFields"/> to it. 
								Since jOOQ 1.3, there is also the possibility to
								create SELECT statements using jOOQ's 
								<reference id="DSL" title="DSL API"/> in a much more intuitive
								and SQL-like way. 
							</p>
							<p>Use the DSL API when: </p>
							<ul>
								<li>You want your code to look like SQL</li>
								<li>You want your IDE to help you with auto-completion (you will not be able to write select .. order by .. where .. join or any of that stuff) </li>
							</ul>
							<p>Use the regular API when: </p>
							<ul>
								<li>You want to create your query step-by-step, creating query parts one-by-one</li>
							    <li>You need to assemble your query from various places, passing the query around, adding new conditions and joins on the way </li>
							</ul>
							<p>In any case, all API's will construct the same underlying
								implementation object, and in many cases, you can combine the two
								approaches. Let's check out the various SELECT statement types: </p>
								
							<ul>
								<li><reference class="org.jooq.Select"/>: 
								    This Query subtype stands for a general type of SELECT statement. 
								    It is also the main Select type for the 
								    <reference id="DSL" title="DSL API"/>. When executed, this object 
								    will hold a <reference id="Result" title="Result containing the resulting Records"/>. 
								    This type is further subtyped for the various uses of a SELECT statement as such:</li> 
								<li><reference class="org.jooq.SimpleSelectQuery"/>:
									This Query will allow for selecting from single physical Tables only.
									It therefore has access to the Table's generic type parameter 
									&lt;R extends Record&gt; and will provide a matching Result&lt;R&gt;. 
									This is especially useful if &lt;R&gt; is a subtype of 
									<reference id="UpdatableRecord" title="UpdatableRecord"/>.
									Then you will be able to perform updates on your result set immediately.</li>
								<li><reference class="org.jooq.SelectQuery"/>:
									This Query will allow for selecting a subset of Fields from several 
									Tables. Because the results of such a query are considered of an anonymous
									or ad-hoc type, this Query will bind &lt;R&gt; to the general type Record 
									itself. The purpose of this Query type is to allow for full SQL support, 
									including SELECT, JOIN and GROUP BY clauses. </li>
							</ul>
							
							<h3>Example: SQL query and DSL query</h3>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left">A sample SQL statement</td>
								<td width="50%" class="right">...and its equivalent in jOOQ's DSL API</td>
							</tr>
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">
-- Select all books by authors born after 1920, named "Paulo" 
-- from a catalogue consisting of authors and books:


SELECT * 
  FROM t_author a 
  JOIN t_book b 
    ON a.id = b.author_id 
 WHERE a.year_of_birth &gt; 1920 
   AND a.first_name = 'Paulo'
 ORDER BY b.title</pre></td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
// Instanciate your factory using a JDBC connection.
Factory create = new Factory(connection, SQLDialect.ORACLE);

// Execute the query "on a single line"
Result&lt;Record&gt; result = create.select()
    .from(T_AUTHOR)
    .join(T_BOOK)
    .on(ID.equal(AUTHOR_ID))
    .where(YEAR_OF_BIRTH.greaterThan(1920)
    .and(FIRST_NAME.equal("Paulo")))
    .orderBy(TITLE).fetch();</pre></td>
							</tr>
							</table>
							
							<p>
								In the above example, some generated artefacts are used for querying. 
								In this case, T_AUTHOR and T_BOOK are instances of types 
								<reference class="org.jooq.test.oracle.generatedclasses.tables.TAuthor" title="TAuthor"/> and 
								<reference class="org.jooq.test.oracle.generatedclasses.tables.TBook" title="TBook"/> respectively. 
								Their full qualification would read TAuthor.T_AUTHOR and TBook.T_BOOK, but in many cases, 
								it's useful to static import elements involved with queries, in order to decrease verbosity. 
							</p>
							
							<p>
								Apart from the singleton Table instances TAuthor.T_AUTHOR and
								TBook.T_BOOK, these generated classes also contain one static member
								for every physical field, such as TAuthor.ID or TBook.TAUTHOR_ID, etc. 
							</p>
							
							<ul>
								<li>For more information about code generation, check out the manual's section about 
									<reference id="META" title="Meta model source code generation"/>.</li>
    							<li>For more DSL examples, please consider the manual's section about the 
    								<reference id="DSL" title="DSL API"/>.</li>
							</ul>
							
							<h3>Example: Non-DSL query</h3>
							<p>
								If you choose not to use the DSL API (for instance, because you don't
								want to add Query parts in the order SQL expects them), you can use
								this syntax: 
							</p>
							<pre class="prettyprint lang-java">
// Re-use the factory to create a SelectQuery. This example will not make use of static imports...
SelectQuery q = create.selectQuery();
q.addFrom(TAuthor.T_AUTHOR);

// This example shows some "mixed" API usage, where the JOIN is added with the standard API, and the 
// Condition is created using the DSL API
q.addJoin(TBook.T_BOOK, TAuthor.ID.equal(TBook.AUTHOR_ID));

// The AND operator between Conditions is implicit here
q.addConditions(TAuthor.YEAR_OF_BIRTH.greaterThan(1920));
q.addConditions(TAuthor.FIRST_NAME.equal("Paulo"));
q.addOrderBy(TBook.TITLE);</pre>

							<h3>Fetching data</h3>
							<p>
								The <reference class="org.jooq.Select"/> interface extends 
								<reference class="org.jooq.ResultQuery"/>, 
								which provides a range of methods to fetch data from the database. 
								Once you have constructed your SELECT query (see examples above), you 
								may choose to either simply execute() it, or use a variety of convenience
								fetchXXX() methods. 
							</p>
							<p>
								See the manual's 
								<reference id="ResultQuery" title="section on the ResultQuery"/>
								for more details. 
							</p>
							
							
							<h2>INSERT Statements</h2>
							<p>jOOQ supports two modes for INSERT statements. 
							The INSERT VALUES and the INSERT SELECT syntax</p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left">A typical INSERT query looks like this</td>
								<td width="50%" class="right">...and how it's done with jOOQ</td>
							</tr>
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">
INSERT INTO T_AUTHOR 
    (ID, FIRST_NAME, LAST_NAME)
VALUES 
    (100, 'Hermann', 'Hesse'),
    (101, 'Alfred', 'Döblin');</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
create.insertInto(T_AUTHOR, 
          TAuthor.ID, TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .values(100, "Hermann", "Hesse")
      .values(101, "Alfred", "Döblin")
      .execute();</pre></td>
							</tr>
							</table>

							<p>The DSL syntax tries to stay close to actual SQL. In detail,
								however, Java is limited in its possibilities. That's why the
								.values() clause is repeated for every record. Some RDBMS support
								inserting several records at the same time. This is also supported in
								jOOQ, and simulated using INSERT INTO .. SELECT .. UNION ALL SELECT ..
								clauses for those RDBMS that don't support this syntax.
							</p>
							<p>Note: Just like in SQL itself, you can have syntax errors when you
								don't have matching numbers of fields/values. Also, you can run into
								runtime problems, if your field/value types don't match. </p>
								
							<h3>Example: DSL Query, alternative syntax</h3>
							<p>MySQL (and some other RDBMS) allow for using an UPDATE-like syntax
								for INSERT statements. This is also supported in jOOQ, should you
								prefer that syntax. The above INSERT statement can also be expressed
								as follows: </p>
							<pre class="prettyprint lang-java">
create.insertInto(T_AUTHOR)
      .set(TAuthor.ID, 100)
      .set(TAuthor.FIRST_NAME, "Hermann")
      .set(TAuthor.LAST_NAME, "Hesse")
      .newRecord()
      .set(TAuthor.ID, 101)
      .set(TAuthor.FIRST_NAME, "Alfred")
      .set(TAuthor.LAST_NAME, "Döblin")
      .execute();</pre>
							<p>As you can see, this syntax is a bit more verbose, but also more
								type-safe, as every field can be matched with its value.</p>
								
							<h3>Example: ON DUPLICATE KEY UPDATE clause</h3>
							<p>The MySQL database supports a very convenient way to INSERT or
								UPDATE a record. This is a non-standard extension to the SQL syntax,
								which is supported by jOOQ and simulated in other RDBMS, where this is
								possible. Here is an example how to use the ON DUPLICATE KEY UPDATE
								clause: </p>
							<pre class="prettyprint lang-java">
// Add a new author called "Koontz" with ID 3.
// If that ID is already present, update the author's name
create.insertInto(T_AUTHOR, TAuthor.ID, TAuthor.LAST_NAME)
      .values(3, "Koontz")
      .onDuplicateKeyUpdate()
      .set(TAuthor.LAST_NAME, "Koontz")
      .execute();</pre>
      
      						<h3>Example: INSERT .. RETURNING clause</h3>
							<p>The Postgres database has native support for an INSERT .. RETURNING
								clause. This is a very powerful concept that is simulated for all
								other dialects using JDBC's 
								<reference class="java.sql.Statement" anchor="#getGeneratedKeys()" title="getGeneratedKeys()"/> 
								method. Take this example:</p>
								
							<pre class="prettyprint lang-java">
// Add another author, with a generated ID
Record&lt;?&gt; record =
create.insertInto(T_AUTHOR, TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .values("Charlotte", "Roche")
      .returning(TAuthor.ID)
      .fetchOne();

System.out.println(record.getValue(TAuthor.ID));

// For some RDBMS, this also works when inserting several values
Result&lt;?&gt; result =
create.insertInto(T_AUTHOR, TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .values("Johann Wolfgang", "von Goethe")
      .values("Friedrich", "Schiller")
      // You can request any field. Also trigger-generated values
      .returning(TAuthor.ID, TAuthor.CREATION_DATE)
      .fetch();</pre>
      						
      						<h3>Example: Non-DSL Query</h3>
      						<p>You can always use the more verbose regular syntax of the InsertQuery, if you need more control: </p>
      						<pre class="prettyprint lang-java">
// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(TAuthor.ID, 100);
i.addValue(TAuthor.FIRST_NAME, "Hermann");
i.addValue(TAuthor.LAST_NAME, "Hesse");

i.newRecord();
i.addValue(TAuthor.ID, 101);
i.addValue(TAuthor.FIRST_NAME, "Alfred");
i.addValue(TAuthor.LAST_NAME, "Döblin");
i.execute();</pre>

							<h3>Example: INSERT Query combined with SELECT statements</h3>
							<p>The InsertQuery.addValue() method is overloaded, such that you can
								also provide a Field, potentially containing an expression: </p>
							<pre class="prettyprint lang-java">
// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(TAuthor.ID, create.select(TAuthor.ID.max().add(1)).from(T_AUTHOR).asField())
i.addValue(TAuthor.FIRST_NAME, "Hermann");
i.addValue(TAuthor.LAST_NAME, "Hesse");
i.execute();</pre>
							<p>Note that especially MySQL (and some other RDBMS) has some
								limitations regarding that syntax. You may not be able to
								select from the same table you're inserting into</p>
								
							<h3>Example: INSERT SELECT syntax support</h3>
							<p>In some occasions, you may prefer the INSERT SELECT syntax, for instance, when 
								you copy records from one table to another: </p>
							<pre class="prettyprint lang-java">
Insert i = create.insertInto(T_AUTHOR_ARCHIVE,
           create.selectFrom(T_AUTHOR).where(TAuthor.DECEASED.equal(1)));
i.execute();</pre>

							
							<h2>UPDATE Statements</h2>
							<p>UPDATE statements are only possible on single tables. Support for 
							multi-table updates will be implemented in the near future. </p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left">A typical UPDATE query looks like this</td>
								<td width="50%" class="right">...and how it's done with jOOQ</td>
							</tr>
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">

UPDATE T_AUTHOR
   SET FIRST_NAME = 'Hermann',
       LAST_NAME = 'Hesse'
 WHERE ID = 3;</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
create.update(T_AUTHOR)
      .set(TAuthor.FIRST_NAME, "Hermann")
      .set(TAuthor.LAST_NAME, "Hesse")
      .where(TAuthor.ID.equal(3))
      .execute();</pre></td>
							</tr>
							</table>
							
							<h3>Example: Non-DSL Query</h3>
							<p>Using the <reference class="org.jooq.UpdateQuery"/> class, 
							this is how you could express an UPDATE statement:</p> 
							<pre class="prettyprint lang-java">
UpdateQuery&lt;TAuthorRecord&gt; u = create.updateQuery(T_AUTHOR);
u.addValue(TAuthor.FIRST_NAME, "Hermann");
u.addValue(TAuthor.FIRST_NAME, "Hesse");
u.addConditions(TAuthor.ID.equal(3));
u.execute();</pre>

							
							<h2>DELETE Statements</h2>
							<p>DELETE statements are only possible on single tables. Support for 
							multi-table deletes will be implemented in the near future. </p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left">A typical DELETE query looks like this</td>
								<td width="50%" class="right">...and how it's done with jOOQ</td>
							</tr>
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">

DELETE T_AUTHOR
 WHERE ID = 100;</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
create.delete(T_AUTHOR)
      .where(TAuthor.ID.equal(100))
      .execute();</pre></td>
							</tr>
							</table>
							
							<h3>Example: Non-DSL Query</h3>
							<p>Using the <reference class="org.jooq.DeleteQuery"/> class, 
							this is how you could express a DELETE statement: </p> 
							<pre class="prettyprint lang-java">
DeleteQuery&lt;TAuthorRecord&gt; d = create.deleteQuery(T_AUTHOR);
d.addConditions(TAuthor.ID.equal(100));
d.execute();</pre>


							<h2>MERGE Statement</h2>
							<p>
								The MERGE statement is one of the most advanced standardised SQL
								constructs, which is supported by DB2, HSQLDB, Oracle, SQL Server and
								Sybase (MySQL has the similar INSERT .. ON DUPLICATE KEY UPDATE
								construct. H2's MERGE variant is currently not supported.)
							</p>
							<p>
								The point of the standard MERGE statement is to take a TARGET table, and
								merge (INSERT, UPDATE) data from a SOURCE table into it. DB2, Oracle,
								SQL Server and Sybase also allow for DELETING some data and for adding
								many additional clauses. Those non-standard extensions are currently
								not supported. Here is an example:
							</p>
							
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">
-- Check if there is already an author called 'Hitchcock'
-- If there is, rename him to John. If there isn't add him.

MERGE INTO T_AUTHOR
USING (SELECT 1 FROM DUAL)
ON (LAST_NAME = 'Hitchcock')
WHEN MATCHED THEN UPDATE SET FIRST_NAME = 'John'
WHEN NOT MATCHED THEN INSERT (LAST_NAME) VALUES ('Hitchcock')</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
create.mergeInto(T_AUTHOR)
      .using(create().selectOne())
      .on(TAuthor.LAST_NAME.equal("Hitchcock"))
      .whenMatchedThenUpdate()
      .set(TAuthor.FIRST_NAME, "John")
      .whenNotMatchedThenInsert(TAuthor.LAST_NAME)
      .values("Hitchcock")
      .execute();</pre></td>
							</tr>
							</table>
							
							
							<h2>TRUNCATE Statement</h2>
							<p>
								The syntax is trivial:
							</p>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">TRUNCATE TABLE T_AUTHOR;</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">create.truncate(T_AUTHOR).execute();</pre></td>
							</tr>
							</table>
							<p>This is not supported by Ingres and SQLite. jOOQ will execute a DELETE FROM
								T_AUTHOR statement instead. </p>
						</content>
					</section>
					
					
					
					<section id="ResultQuery">
						<title>ResultQuery and various ways of fetching data</title>
					</section>
					<section id="QueryPart">
						<title>QueryParts and the global architecture</title>
					</section>
					<section id="Serializability">
						<title>Serializability of QueryParts and Results</title>
					</section>
					<section id="Extend">
						<title>Extend jOOQ types with custom implementations</title>
					</section>
				</sections>
			</section>
			<section id="META">
				<title>Meta model code generation</title>
				<sections>
					<section id="Configuration">
						<title>Configuration and setup</title>
					</section>
					<section id="SCHEMA">
						<title>Schemata</title>
					</section>
					<section id="TABLE">
						<title>Tables and views and their corresponding records</title>
					</section>
					<section id="PROCEDURE">
						<title>Procedures and packages</title>
					</section>
					<section id="UDT">
						<title>UDT's including ARRAY and ENUM types</title>
					</section>
					<section id="SEQUENCE">
						<title>Sequences</title>
					</section>
				</sections>
			</section>
			<section id="DSL">
				<title>DSL or fluent API. Where SQL meets Java</title>
				<sections>
					<section id="SELECT">
						<title>Complete SELECT syntax</title>
					</section>
					<section id="CONDITION">
						<title>Conditions</title>
					</section>
					<section id="ALIAS">
						<title>Aliased tables and fields</title>
					</section>
					<section id="IN">
						<title>Nested select statements using the IN operator</title>
					</section>
					<section id="EXISTS">
						<title>Nested select statements using the EXISTS operator</title>
					</section>
					<section id="NESTED">
						<title>Other types of nested selects</title>
					</section>
					<section id="UNION">
						<title>UNION and other set operations</title>
					</section>
					<section id="FUNCTIONS">
						<title>Functions, aggregate operators, and window functions</title>
					</section>
					<section id="PROCEDURES">
						<title>Stored procedures and functions</title>
					</section>
					<section id="ARITHMETIC">
						<title>Arithmetic operations</title>
					</section>
					<section id="CASE">
						<title>The CASE clause</title>
					</section>
					<section id="CAST">
						<title>Type casting</title>
					</section>
					<section id="SQL">
						<title>When it's just much easier: Plain SQL</title>
					</section>
				</sections>
			</section>
			<section id="ADVANCED">
				<title>Advanced topics</title>
				<sections>
					<section id="MasterData">
						<title>Master data generation</title>
					</section>
					<section id="SchemaMapping">
						<title>Mapping generated schemata and tables to productive environments</title>
					</section>
					<section id="OracleHints">
						<title>Adding Oracle hints to queries</title>
					</section>
					<section id="CONNECTBY">
						<title>The Oracle CONNECT BY clause for hierarchical queries</title>
					</section>
					<section id="Export">
						<title>Exporting data to XML, CSV, JSON, HTML, Text</title>
					</section>
					<section id="Import">
						<title>Importing data from XML, CSV</title>
					</section>
				</sections>
			</section>
		</sections>
	</section>
</manual>