<?xml version="1.0" encoding="UTF-8"?>
<manual>
	<section id="manual">
		<title>The jOOQ User Manual</title>
		<slogan>
			Learn about jOOQ using its single or multi-paged manuals
		</slogan>
		<content>
			<h3>Single-paged manuals</h3>
			<p>Coming soon in the manuals section of the jOOQ website:</p>
			<ul>
				<li>A single-paged HTML manual</li>
				<li>A downloadable PDF manual</li>
			</ul>
			<h3>The multi-paged manual</h3>
			<p>This manual is divided into four main sections:</p>
			<ul>
				<li>
					<reference id="JOOQ"/>
					<p>
						See these chapters for an overview of the jOOQ internal architecture
						and all types that are involved with jOOQ's query creation and
						execution. This is the important part for you, also, if you wish to
						extend jOOQ
					</p>
				</li>
				<li>
					<reference id="META"/>
					<p>
						See these chapters to understand how you can use jOOQ as a source code
						generator, and what type of artefacts are generated by jOOQ
					</p>
				</li>
				<li>
					<reference id="DSL"/>
					<p>
						See these chapters to learn about how to use jOOQ in every day's work. The
						jOOQ DSL is the main way to create and execute jOOQ queries almost as
						if SQL was embedded in Java directly
					</p>
				</li>
				<li>
					<reference id="ADVANCED"/>
					<p>
						Some advanced topics including not-everyday functionality
					</p>
				</li>
			</ul>
		</content>
		
		
		<sections>
			<section id="JOOQ">
				<title>jOOQ classes and their usage</title>
				<slogan>
					In these sections, you will learn about how to use jOOQ object
					factories and the jOOQ query model, to express
					your SQL in jOOQ
				</slogan>
				<content>
					<h2>Overview</h2>
					<p>jOOQ essentially has two packages:</p>
					<ul>
						<li>org.jooq: the jOOQ API. Here you will find interfaces for all
							SQL concepts
						</li>
						<li>org.jooq.impl: the jOOQ implementation and factories. Most
							implementation classes are package private, you can only access
							them using the <reference id="Factory" title="org.jooq.impl.Factory"/> 
						</li>
					</ul>
					<p>
						This section is about the main jOOQ classes and the global
						architecture. Most of the time, however, you will be using the
						<reference id="DSL" />
						in order to create queries
						the way you're used to in SQL
					</p>
				</content>
				
				
				<sections>
					<section id="ExampleDatabase">
						<title>The example database</title>
						<slogan>
							For the examples in this manual, the same database will always be
							referred to. It essentially consists of these entities created using
							the Oracle dialect
						</slogan>
						<content>
							<h2>Example CREATE TABLE statements</h2>
							<pre class="prettyprint lang-sql">
CREATE TABLE t_language (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  cd CHAR(2) NOT NULL,
  description VARCHAR2(50)
)

CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50) NOT NULL,
  date_of_birth DATE,
  year_of_birth NUMBER(7)
)

CREATE TABLE t_book (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  author_id NUMBER(7) NOT NULL,
  title VARCHAR2(400) NOT NULL,
  published_in NUMBER(7) NOT NULL,
  language_id NUMBER(7) NOT NULL,
  FOREIGN KEY (AUTHOR_ID) REFERENCES T_AUTHOR(ID),
  FOREIGN KEY (LANGUAGE_ID) REFERENCES T_LANGUAGE(ID)
)

CREATE TABLE t_book_store (
  name VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE t_book_to_book_store (
  book_store_name VARCHAR2(400) NOT NULL,
  book_id INTEGER NOT NULL,
  stock INTEGER,
  PRIMARY KEY(book_store_name, book_id),
  CONSTRAINT b2bs_book_store_id
    FOREIGN KEY (book_store_name)
    REFERENCES t_book_store (name)
    ON DELETE CASCADE,
  CONSTRAINT b2bs_book_id
    FOREIGN KEY (book_id)
    REFERENCES t_book (id)
    ON DELETE CASCADE
)							
							</pre>
							<p>
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc),
								stored procedures and packages are introduced for specific examples
							</p>
						</content>
					</section>
					
					
					<section id="Factory">
						<title>The Factory class</title>
						<slogan>
							jOOQ hides most implementation facts from you by letting you
							use the jOOQ Factory as a single entry point to all of the jOOQ API.
							This way, you can discover all of the API using syntax auto-completion, for
							instance. 
						</slogan>
						<content>
							<h2>The Factory and the jOOQ API</h2>
							<p>
								jOOQ exposes a lot of interfaces and hides most implementation facts 
								from client code. The reasons for this are: 
							</p>
							<ul>
								<li>Interface-driven design. This allows for modelling queries in a fluent API most efficiently</li>
								<li>Reduction of complexity for client code.</li>
								<li>API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</li>
							</ul>
							<p>
								The <reference class="org.jooq.impl.Factory"/> 
								class is the main class from where you will create all jOOQ objects. 
								The Factory implements <reference class="org.jooq.Configuration"/> 
								and needs to be instanciated with the Configuration's properties: 
							</p>
							<ul>
								<li><reference class="org.jooq.SQLDialect"/> : 
								The dialect of your database. This may be any of the currently
								supported database types</li>
								<li><reference class="java.sql.Connection"/> : 
								A JDBC Connection that will be re-used for the whole
    							lifecycle of your Factory</li>
    							<li><reference class="org.jooq.SchemaMapping"/> : 
    							An optional mapping of schemata. Check out the 
    							<reference id="SchemaMapping" title="SchemaMapping"/>
    							page for details</li> 
							</ul>
							<p>If you are planning on using several RDBMS (= SQLDialects) or
								several distinct JDBC Connections in your software, this will mean
								that you have to create a new Factory every time. </p>
							
							<h3>Factory subclasses</h3>
							<p>
								There are a couple of subclasses for the general Factory. Each SQL
								dialect has its own dialect-specific factory. For instance, if you're
								only using the MySQL dialect, you can choose to create a new Factory
								using any of the following types: 
							</p>
							<pre class="prettyprint lang-java">
// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);
							</pre>
							<p>
								The advantage of using a dialect-specific Factory lies in the fact,
								that you have access to more proprietary RDMBS functionality. This may
								include: 
							</p>
							<ul>
								<li>Oracle's <reference id="CONNECTBY" title="CONNECT BY"/>
								    pseudo columns and functions</li>
    							<li>MySQL's encryption functions</li>
    							<li>PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</li>
							</ul>
							<p>
								Another type of Factory subclasses are each generated schema's
								factories. If you generate your schema TEST, then you will have access
								to a TestFactory. This will be useful in the future, when access to
								schema artefacts will be unified. Currently, this has no use. 
							</p>
							
							<h3>Potential problems</h3>
							<p>
								The jOOQ Factory expects its underlying
								<reference class="java.sql.Connection" />
								to be <strong>open and ready</strong>
								for
								<reference class="java.sql.PreparedStatement" />
								creation. You are responsible yourself for the
								lifecycle dependency between Factory and Connection. This means: 
							</p>
							<ul>
								<li>jOOQ will never close the Connection.</li>
								<li>jOOQ will never commit or rollback on the Connection 
									(Except for CSV-imports, if explicitly configured in the <reference id="Import" title="Import API"/>)</li>
								<li>jOOQ will never start any transactions.</li>
								<li>
									jOOQ does not know the concept of a session as for instance
									<a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/architecture.html#architecture-current-session">Hibernate</a>
								</li>
								<li>jOOQ does not know the concept of a second-level cache. SQL is
									executed directly on the underlying RDBMS.</li>
								<li>jOOQ does not make assumptions about the origin of the Connection.
									If it is container managed, that is fine.</li> 
							</ul>
							<p>
								So if you want your queries to run in separate transactions, if you
								want to roll back a transactions, if you want to close a Connection and
								return it to your container, you will have to take care of that
								yourself. jOOQ's Factory will always expect its Connection to be in a
								ready state for creating new PreparedStatements. If it is not, you have
								to create a new Factory. 
							</p>
							<p>
								Please keep in mind that many jOOQ objects will reference your Factory
								for their whole lifecycle. This is especially interesting, when dealing
								with <reference id="UpdatableRecord" title="Updatable Records"/>,
								that can perform CRUD operations on the
								Factory's underlying Connection.
							</p>
						</content>
					</section>
					
					
					<section id="Table">
						<title>Tables and Fields</title>
						<slogan>
							Tables and their Fields are probably the most important objects in
							jOOQ. Tables represent any entity in your underlying RDBMS, that holds
							data for selection, insertion, updates, and deletion. In other words,
							views are also considered tables by jOOQ. 
						</slogan>
						<content>
							<h2>The Table</h2>
							<p>The formal definition of a <reference class="org.jooq.Table"/> starts with </p>
							<pre class="prettyprint lang-java">public interface Table&lt;R extends Record&gt; // [...]</pre>
							<p>
								This means that every table is associated with a subtype of the
								<reference class="org.jooq.Record" />
								class (see also
								<reference id="Result" title="Results and Records" />
								). For anonymous or ad-hoc tables,
								&lt;R&gt; will always bind to Record itself. 
							</p>
							<p>
								Unlike in the
								<a href="http://download.oracle.com/javaee/6/tutorial/doc/gjitv.html"
									title="Tutorial about JPA CriteriaQuery">JPA CriteriaQuery API</a>,
								this generic type
								&lt;R&gt;
								is not given so much importance as far as
								type-safety is concerned.
								SQL itself is inherently type-unsafe. But then
								again, you have
								incredible flexibility of creating anonymous or ad-hoc
								types and
								reusing them from
								<reference id="NESTED" title="NESTED SELECT statements" />
								or from many other
								use-cases. If
								&lt;R&gt; would play a role as important
								as in JPA, jOOQ
								would suffer from
								the same verbosity, or inflexibility
								that JPA
								CriteriaQueries may
								have. 
							</p>
							
							<h2>The Field</h2>
							<p>The formal definition of a Field starts with </p>
							<pre class="prettyprint lang-java">public interface Field&lt;T&gt; // [...]</pre>
							<p>
								Fields are generically parameterised with a Java type
								&lt;T&gt;
								that reflects the closest match to the RDMBS's underlying datatype for that
								field. For instance, if you have a VARCHAR2 type Field in Oracle,
								&lt;T&gt;
								would bind to
								<reference class="java.lang.String" />
								for that Field in jOOQ. Oracle's NUMBER(7) would
								let
								&lt;T&gt;
								bind to
								<reference class="java.lang.Integer" />,
								etc. This generic type is useful for two purposes:
							</p>
							<ul>
								<li>It allows you to write type safe queries. For instance, you cannot
									compare Field
									&lt;String&gt;
									with Field
									&lt;Integer&gt;</li>
						
								<li>It
									allows you to fetch correctly cast and converted values from
									your database result set. This is especially useful when &lt;T&gt; binds
									to
									advanced data types, such as
									<reference id="UDT" title="UDT's, ARRAY or ENUM types" />
									, where jOOQ
									does the difficult non-standardised JDBC data type conversions for you.
								</li>
							</ul> 
							
							<h2>Fields and tables put into action</h2>
							<p>The Field itself is a very broad concept. Other tools, or databases
								refer to it as expression or column. When you just want to </p>
								
							<pre class="prettyprint lang-sql">SELECT 1 FROM DUAL</pre>
							<p>
								Then 1 is considered a Field or more explicitly, a
								<reference class="org.jooq.impl.Constant" />, 
								which implements Field, and DUAL is considered a Table or more explicitly 
								<reference class="org.jooq.impl.Dual"/>, which implements Table
							</p>
							<p>
								More advanced uses become clear quickly, when you do things like 
							</p>
							<pre class="prettyprint lang-sql">SELECT 1 + 1 FROM DUAL</pre>
							<p>
								Where 1 + 1 itself is a Field or more explicitly, an 
								<reference class="org.jooq.impl.Expression"/> 
								joining two Constants together. 
							</p>
							<p>
								See some details about how to create these queries in the
								<reference id="Query" title="Query section"/> of the manual 
							</p>
							
							<h2>TableFields</h2>
							<p>
								A specific type of field is the
								<reference class="org.jooq.TableField" />,
								which represents a physical
								Field in a physical Table. Both the
								TableField and its referenced Table
								know each other. The physical aspect
								of their nature is represented in
								jOOQ by
								<reference id="TABLE" title="meta model code generation" />,
								where every entity in your database
								schema will be generated into a
								corresponding Java class.
							</p>
							<p>
								TableFields join both &lt;R&gt; and &lt;T&gt; generic parameters into their specification: 
							</p>
							<pre class="prettyprint lang-java">public interface TableField&lt;R extends Record, T&gt; // [...]</pre>
							<p>
								This can be used for additional type safety in the future, or by client code.
							</p>
						</content>
					</section>
					
					
					<section id="Result">
						<title>Results and Records</title>
						<slogan>
							Results and their Records come into play, when SELECT statements are
							executed. There are various ways to fetch data from a jOOQ SELECT
							statement. Essentially, the query results are always provided in the
							Result API
						</slogan>
						<content>
							<h2>The Result</h2>
							<p>
								The
								<reference class="org.jooq.Result" title="Result" />&lt;R extends <reference class="org.jooq.Record" title="Record" />&gt;
								is essentially a wrapper for a List&lt;R extends Record&gt;
								providing
								many convenience methods for accessing single elements in
								the result
								set. Depending on the type of SELECT statement,
								&lt;R&gt; can be bound
								to a sub-type of Record, for instance to an
								<reference class="org.jooq.UpdatableRecord" />. 
								See the section on
								<reference id="UpdatableRecord" title="Updatable Records" />
								for further details. 
							</p>
							
							<h2>The Cursor</h2>
							<p>
								A similar object is the 
								<reference class="org.jooq.Cursor" title="Cursor"/>&lt;R extends Record&gt;. 
								Unlike the Result, the cursor has not fetched all data from the database yet. 
								This means, you save memory (and potentially speed), but you can only access 
								data sequentially and you have to keep a JDBC ResultSet alive. Cursors behave 
								very much like the <reference class="java.util.Iterator"/>, 
								by providing a very simple API: 
							</p>
							<pre class="prettyprint lang-java">
// Check whether there are any more records to be fetched
boolean hasNext() throws SQLException;

// Fetch the next record from the underlying JDBC ResultSet
R fetchOne() throws SQLException;

// Close the underlying JDBC ResultSet. Don't forget to call this, before disposing the Cursor.
void close() throws SQLException;</pre>

							<h2>The Record</h2>
							<p>
								The Record itself holds all the data from your selected tuple. If it is
								a <reference class="org.jooq.TableRecord"/>, then it corresponds exactly to the type of one of your
								physical tables in your database. But any anonymous or ad-hoc tuple can
								be represented by the plain Record. A record mainly provides access to
								its data and adds convenience methods for data type conversion. These
								are the main access ways: 
							</p>
							<pre class="prettyprint lang-java">
// If you can keep a reference of the selected field, then you can get the corresponding value type-safely
&lt;T&gt; T getValue(Field&lt;T&gt; field);

// If you know the name of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(String fieldName);

// If you know the index of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(int index);</pre>
							<p>
								In some cases, you will not be able to reference the selected Fields
								both when you create the SELECT statement and when you fetch data from
								Records. Then you might use field names or indexes, as with JDBC.
								However, of course, the type information will then be lost as well. If
								you know what type you want to get, you can always use the Record's
								convenience methods for type conversion, however. Some examples: 
							</p>
							<pre class="prettyprint lang-java">
// These methods will try to convert a value to a BigDecimal.
// This will work for all numeric types and for CHAR/VARCHAR types, if they contain numeric values:
BigDecimal getValueAsBigDecimal(String fieldName);
BigDecimal getValueAsBigDecimal(int fieldIndex);

// This method can perform arbitrary conversions
&lt;T&gt; T getValue(String fieldName, Class&lt;? extends T&gt; type);
&lt;T&gt; T getValue(int fieldIndex, Class&lt;? extends T&gt; type);</pre>
						</content>
					</section>
					
					
					<section id="UpdatableRecord">
						<title>Updatable Records</title>
						<slogan>
							UpdatableRecords are a specific subtype of TableRecord that have
							primary key information associated with them.
						</slogan>
						<content>
							<h2>CRUD Operations</h2>
							<p>As of jOOQ 1.5, the UpdatableRecord essentially contains three additional
							 methods <a href="http://de.wikipedia.org/wiki/CRUD">CRUD</a> 
							 (Create Read Update Delete) operations: </p>
							<pre class="prettyprint lang-java">
// Store any changes made to this record to the database.
// The record executes an INSERT if the PRIMARY KEY is NULL or has been changed. Otherwise, an UPDATE is performed.
int store();

// Deletes the record from the database.
int delete();

// Reflects changes made in the database to this Record
void refresh();</pre>
							<p>An example lifecycle of a book can be implemented as such:</p>
							<pre class="prettyprint lang-java">
// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.store();

// Update it with new values
book.setPublishedIn(2010);
book.store();

// Delete it
book.delete();</pre>
							<p>These operations are very simple utilities. They do not 
							reflect the functionality offered by <a href="http://www.hibernate.org/">Hibernate</a> 
							or other persistence managers. </p>
							
							<h2>Performing CRUD on non-updatable records</h2>
							<p>
								If the jOOQ code-generator cannot detect any PRIMARY KEY, or UNIQUE KEY
								on your tables, then the generated artefacts implement TableRecord,
								instead of UpdatableRecord. A TableRecord can perform the same CRUD
								operations as we have seen before, if you provide it with the necessary
								key fields. The API looks like this: 
							</p>
							
							<pre class="prettyprint lang-java">
// INSERT or UPDATE the record using the provided keys
int storeUsing(TableField&lt;R, ?&gt;... keys)

// DELETE a record using the provided keys
int deleteUsing(TableField&lt;R, ?&gt;... keys);

// Reflects changes made in the database to this Record
void refreshUsing(TableField&lt;R, ?&gt;... keys);</pre>
						
							<p>
								This is useful if your RDBMS does not support referential constraints (e.g. MySQL's 
								<a href="http://en.wikipedia.org/wiki/MyISAM">MyISAM</a>), or if you want to 
								store records to an unconstrained view. An example lifecycle of a book without 
								any keys can then be implemented as such: 
							</p>
							<pre class="prettyprint lang-lava">
// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.storeUsing(TBook.ID);

// Update it with new values
book.setPublishedIn(2010);
book.storeUsing(TBook.ID);

// Delete it
book.deleteUsing(TBook.ID);</pre>
						</content>
					</section>
					
					
					<section id="Query">
						<title>The Query and its various subtypes</title>
						<slogan>
							The Query type hierarchy is what you use to execute queries. It has the
							following subtypes for each kind of operation
						</slogan>
						<content>
							<h2>SELECT statements</h2>
							<p>
								There are essentially two ways of creating SELECT statements in jOOQ.
								For historical reasons, you can create 
								<reference class="org.jooq.SimpleSelectQuery"/> or 
								<reference class="org.jooq.SelectQuery"/>
								objects and add additional query clauses, such as 
								<reference class="org.jooq.Condition" title="Conditions"/> or
								<reference class="org.jooq.SortField" title="SortFields"/> to it. 
								Since jOOQ 1.3, there is also the possibility to
								create SELECT statements using jOOQ's 
								<reference id="DSL" title="DSL API"/> in a much more intuitive
								and SQL-like way. 
							</p>
							<p>Use the DSL API when: </p>
							<ul>
								<li>You want your code to look like SQL</li>
								<li>You want your IDE to help you with auto-completion (you will not be able to write select .. order by .. where .. join or any of that stuff) </li>
							</ul>
							<p>Use the regular API when: </p>
							<ul>
								<li>You want to create your query step-by-step, creating query parts one-by-one</li>
							    <li>You need to assemble your query from various places, passing the query around, adding new conditions and joins on the way </li>
							</ul>
							<p>In any case, all API's will construct the same underlying
								implementation object, and in many cases, you can combine the two
								approaches. Let's check out the various SELECT statement types: </p>
								
							<ul>
								<li><reference class="org.jooq.Select"/>: 
								    This Query subtype stands for a general type of SELECT statement. 
								    It is also the main Select type for the 
								    <reference id="DSL" title="DSL API"/>. When executed, this object 
								    will hold a <reference id="Result" title="Result containing the resulting Records"/>. 
								    This type is further subtyped for the various uses of a SELECT statement as such:</li> 
								<li><reference class="org.jooq.SimpleSelectQuery"/>:
									This Query will allow for selecting from single physical Tables only.
									It therefore has access to the Table's generic type parameter 
									&lt;R extends Record&gt; and will provide a matching Result&lt;R&gt;. 
									This is especially useful if &lt;R&gt; is a subtype of 
									<reference id="UpdatableRecord" title="UpdatableRecord"/>.
									Then you will be able to perform updates on your result set immediately.</li>
								<li><reference class="org.jooq.SelectQuery"/>:
									This Query will allow for selecting a subset of Fields from several 
									Tables. Because the results of such a query are considered of an anonymous
									or ad-hoc type, this Query will bind &lt;R&gt; to the general type Record 
									itself. The purpose of this Query type is to allow for full SQL support, 
									including SELECT, JOIN and GROUP BY clauses. </li>
							</ul>
							
							<h3>Example: SQL query and DSL query</h3>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left">A sample SQL statement</td>
								<td width="50%" class="right">...and its equivalent in jOOQ's DSL API</td>
							</tr>
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">
-- Select all books by authors born after 1920, named "Paulo" 
-- from a catalogue consisting of authors and books:


SELECT * 
  FROM t_author a 
  JOIN t_book b 
    ON a.id = b.author_id 
 WHERE a.year_of_birth &gt; 1920 
   AND a.first_name = 'Paulo'
 ORDER BY b.title</pre></td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
// Instanciate your factory using a JDBC connection.
Factory create = new Factory(connection, SQLDialect.ORACLE);

// Execute the query "on a single line"
Result&lt;Record&gt; result = create.select()
    .from(T_AUTHOR)
    .join(T_BOOK)
    .on(ID.equal(AUTHOR_ID))
    .where(YEAR_OF_BIRTH.greaterThan(1920)
    .and(FIRST_NAME.equal("Paulo")))
    .orderBy(TITLE).fetch();</pre></td>
							</tr>
							</table>
							
							<p>
								In the above example, some generated artefacts are used for querying. 
								In this case, T_AUTHOR and T_BOOK are instances of types 
								<reference class="org.jooq.test.oracle.generatedclasses.tables.TAuthor" title="TAuthor"/> and 
								<reference class="org.jooq.test.oracle.generatedclasses.tables.TBook" title="TBook"/> respectively. 
								Their full qualification would read TAuthor.T_AUTHOR and TBook.T_BOOK, but in many cases, 
								it's useful to static import elements involved with queries, in order to decrease verbosity. 
							</p>
							
							<p>
								Apart from the singleton Table instances TAuthor.T_AUTHOR and
								TBook.T_BOOK, these generated classes also contain one static member
								for every physical field, such as TAuthor.ID or TBook.TAUTHOR_ID, etc. 
							</p>
							
							<ul>
								<li>For more information about code generation, check out the manual's section about 
									<reference id="META" title="Meta model source code generation"/>.</li>
    							<li>For more DSL examples, please consider the manual's section about the 
    								<reference id="DSL" title="DSL API"/>.</li>
							</ul>
							
							<h3>Example: Non-DSL query</h3>
							<p>
								If you choose not to use the DSL API (for instance, because you don't
								want to add Query parts in the order SQL expects them), you can use
								this syntax: 
							</p>
							<pre class="prettyprint lang-java">
// Re-use the factory to create a SelectQuery. This example will not make use of static imports...
SelectQuery q = create.selectQuery();
q.addFrom(TAuthor.T_AUTHOR);

// This example shows some "mixed" API usage, where the JOIN is added with the standard API, and the 
// Condition is created using the DSL API
q.addJoin(TBook.T_BOOK, TAuthor.ID.equal(TBook.AUTHOR_ID));

// The AND operator between Conditions is implicit here
q.addConditions(TAuthor.YEAR_OF_BIRTH.greaterThan(1920));
q.addConditions(TAuthor.FIRST_NAME.equal("Paulo"));
q.addOrderBy(TBook.TITLE);</pre>

							<h3>Fetching data</h3>
							<p>
								The <reference class="org.jooq.Select"/> interface extends 
								<reference class="org.jooq.ResultQuery"/>, 
								which provides a range of methods to fetch data from the database. 
								Once you have constructed your SELECT query (see examples above), you 
								may choose to either simply execute() it, or use a variety of convenience
								fetchXXX() methods. 
							</p>
							<p>
								See the manual's 
								<reference id="ResultQuery" title="section on the ResultQuery"/>
								for more details. 
							</p>
							
							
							<h2>INSERT Statements</h2>
							<p>jOOQ supports two modes for INSERT statements. 
							The INSERT VALUES and the INSERT SELECT syntax</p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left">A typical INSERT query looks like this</td>
								<td width="50%" class="right">...and how it's done with jOOQ</td>
							</tr>
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">
INSERT INTO T_AUTHOR 
    (ID, FIRST_NAME, LAST_NAME)
VALUES 
    (100, 'Hermann', 'Hesse'),
    (101, 'Alfred', 'Döblin');</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
create.insertInto(T_AUTHOR, 
          TAuthor.ID, TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .values(100, "Hermann", "Hesse")
      .values(101, "Alfred", "Döblin")
      .execute();</pre></td>
							</tr>
							</table>

							<p>The DSL syntax tries to stay close to actual SQL. In detail,
								however, Java is limited in its possibilities. That's why the
								.values() clause is repeated for every record. Some RDBMS support
								inserting several records at the same time. This is also supported in
								jOOQ, and simulated using INSERT INTO .. SELECT .. UNION ALL SELECT ..
								clauses for those RDBMS that don't support this syntax.
							</p>
							<p>Note: Just like in SQL itself, you can have syntax errors when you
								don't have matching numbers of fields/values. Also, you can run into
								runtime problems, if your field/value types don't match. </p>
								
							<h3>Example: DSL Query, alternative syntax</h3>
							<p>MySQL (and some other RDBMS) allow for using an UPDATE-like syntax
								for INSERT statements. This is also supported in jOOQ, should you
								prefer that syntax. The above INSERT statement can also be expressed
								as follows: </p>
							<pre class="prettyprint lang-java">
create.insertInto(T_AUTHOR)
      .set(TAuthor.ID, 100)
      .set(TAuthor.FIRST_NAME, "Hermann")
      .set(TAuthor.LAST_NAME, "Hesse")
      .newRecord()
      .set(TAuthor.ID, 101)
      .set(TAuthor.FIRST_NAME, "Alfred")
      .set(TAuthor.LAST_NAME, "Döblin")
      .execute();</pre>
							<p>As you can see, this syntax is a bit more verbose, but also more
								type-safe, as every field can be matched with its value.</p>
								
							<h3>Example: ON DUPLICATE KEY UPDATE clause</h3>
							<p>The MySQL database supports a very convenient way to INSERT or
								UPDATE a record. This is a non-standard extension to the SQL syntax,
								which is supported by jOOQ and simulated in other RDBMS, where this is
								possible. Here is an example how to use the ON DUPLICATE KEY UPDATE
								clause: </p>
							<pre class="prettyprint lang-java">
// Add a new author called "Koontz" with ID 3.
// If that ID is already present, update the author's name
create.insertInto(T_AUTHOR, TAuthor.ID, TAuthor.LAST_NAME)
      .values(3, "Koontz")
      .onDuplicateKeyUpdate()
      .set(TAuthor.LAST_NAME, "Koontz")
      .execute();</pre>
      
      						<h3>Example: INSERT .. RETURNING clause</h3>
							<p>The Postgres database has native support for an INSERT .. RETURNING
								clause. This is a very powerful concept that is simulated for all
								other dialects using JDBC's 
								<reference class="java.sql.Statement" anchor="#getGeneratedKeys()" title="getGeneratedKeys()"/> 
								method. Take this example:</p>
								
							<pre class="prettyprint lang-java">
// Add another author, with a generated ID
Record&lt;?&gt; record =
create.insertInto(T_AUTHOR, TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .values("Charlotte", "Roche")
      .returning(TAuthor.ID)
      .fetchOne();

System.out.println(record.getValue(TAuthor.ID));

// For some RDBMS, this also works when inserting several values
Result&lt;?&gt; result =
create.insertInto(T_AUTHOR, TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .values("Johann Wolfgang", "von Goethe")
      .values("Friedrich", "Schiller")
      // You can request any field. Also trigger-generated values
      .returning(TAuthor.ID, TAuthor.CREATION_DATE)
      .fetch();</pre>
      						
      						<h3>Example: Non-DSL Query</h3>
      						<p>You can always use the more verbose regular syntax of the InsertQuery, if you need more control: </p>
      						<pre class="prettyprint lang-java">
// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(TAuthor.ID, 100);
i.addValue(TAuthor.FIRST_NAME, "Hermann");
i.addValue(TAuthor.LAST_NAME, "Hesse");

i.newRecord();
i.addValue(TAuthor.ID, 101);
i.addValue(TAuthor.FIRST_NAME, "Alfred");
i.addValue(TAuthor.LAST_NAME, "Döblin");
i.execute();</pre>

							<h3>Example: INSERT Query combined with SELECT statements</h3>
							<p>The InsertQuery.addValue() method is overloaded, such that you can
								also provide a Field, potentially containing an expression: </p>
							<pre class="prettyprint lang-java">
// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(TAuthor.ID, create.select(TAuthor.ID.max().add(1)).from(T_AUTHOR).asField())
i.addValue(TAuthor.FIRST_NAME, "Hermann");
i.addValue(TAuthor.LAST_NAME, "Hesse");
i.execute();</pre>
							<p>Note that especially MySQL (and some other RDBMS) has some
								limitations regarding that syntax. You may not be able to
								select from the same table you're inserting into</p>
								
							<h3>Example: INSERT SELECT syntax support</h3>
							<p>In some occasions, you may prefer the INSERT SELECT syntax, for instance, when 
								you copy records from one table to another: </p>
							<pre class="prettyprint lang-java">
Insert i = create.insertInto(T_AUTHOR_ARCHIVE,
           create.selectFrom(T_AUTHOR).where(TAuthor.DECEASED.equal(1)));
i.execute();</pre>

							
							<h2>UPDATE Statements</h2>
							<p>UPDATE statements are only possible on single tables. Support for 
							multi-table updates will be implemented in the near future. </p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left">A typical UPDATE query looks like this</td>
								<td width="50%" class="right">...and how it's done with jOOQ</td>
							</tr>
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">

UPDATE T_AUTHOR
   SET FIRST_NAME = 'Hermann',
       LAST_NAME = 'Hesse'
 WHERE ID = 3;</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
create.update(T_AUTHOR)
      .set(TAuthor.FIRST_NAME, "Hermann")
      .set(TAuthor.LAST_NAME, "Hesse")
      .where(TAuthor.ID.equal(3))
      .execute();</pre></td>
							</tr>
							</table>
							
							<h3>Example: Non-DSL Query</h3>
							<p>Using the <reference class="org.jooq.UpdateQuery"/> class, 
							this is how you could express an UPDATE statement:</p> 
							<pre class="prettyprint lang-java">
UpdateQuery&lt;TAuthorRecord&gt; u = create.updateQuery(T_AUTHOR);
u.addValue(TAuthor.FIRST_NAME, "Hermann");
u.addValue(TAuthor.FIRST_NAME, "Hesse");
u.addConditions(TAuthor.ID.equal(3));
u.execute();</pre>

							
							<h2>DELETE Statements</h2>
							<p>DELETE statements are only possible on single tables. Support for 
							multi-table deletes will be implemented in the near future. </p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left">A typical DELETE query looks like this</td>
								<td width="50%" class="right">...and how it's done with jOOQ</td>
							</tr>
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">

DELETE T_AUTHOR
 WHERE ID = 100;</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
create.delete(T_AUTHOR)
      .where(TAuthor.ID.equal(100))
      .execute();</pre></td>
							</tr>
							</table>
							
							<h3>Example: Non-DSL Query</h3>
							<p>Using the <reference class="org.jooq.DeleteQuery"/> class, 
							this is how you could express a DELETE statement: </p> 
							<pre class="prettyprint lang-java">
DeleteQuery&lt;TAuthorRecord&gt; d = create.deleteQuery(T_AUTHOR);
d.addConditions(TAuthor.ID.equal(100));
d.execute();</pre>


							<h2>MERGE Statement</h2>
							<p>
								The MERGE statement is one of the most advanced standardised SQL
								constructs, which is supported by DB2, HSQLDB, Oracle, SQL Server and
								Sybase (MySQL has the similar INSERT .. ON DUPLICATE KEY UPDATE
								construct. H2's MERGE variant is currently not supported.)
							</p>
							<p>
								The point of the standard MERGE statement is to take a TARGET table, and
								merge (INSERT, UPDATE) data from a SOURCE table into it. DB2, Oracle,
								SQL Server and Sybase also allow for DELETING some data and for adding
								many additional clauses. Those non-standard extensions are currently
								not supported. Here is an example:
							</p>
							
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">
-- Check if there is already an author called 'Hitchcock'
-- If there is, rename him to John. If there isn't add him.

MERGE INTO T_AUTHOR
USING (SELECT 1 FROM DUAL)
ON (LAST_NAME = 'Hitchcock')
WHEN MATCHED THEN UPDATE SET FIRST_NAME = 'John'
WHEN NOT MATCHED THEN INSERT (LAST_NAME) VALUES ('Hitchcock')</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
create.mergeInto(T_AUTHOR)
      .using(create().selectOne())
      .on(TAuthor.LAST_NAME.equal("Hitchcock"))
      .whenMatchedThenUpdate()
      .set(TAuthor.FIRST_NAME, "John")
      .whenNotMatchedThenInsert(TAuthor.LAST_NAME)
      .values("Hitchcock")
      .execute();</pre></td>
							</tr>
							</table>
							
							
							<h2>TRUNCATE Statement</h2>
							<p>
								The syntax is trivial:
							</p>
							<table width="100%" cellpadding="0" cellspacing="0">
							<tr>
								<td width="50%" class="left"><pre class="prettyprint lang-sql">TRUNCATE TABLE T_AUTHOR;</pre>
								</td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">create.truncate(T_AUTHOR).execute();</pre></td>
							</tr>
							</table>
							<p>This is not supported by Ingres and SQLite. jOOQ will execute a DELETE FROM
								T_AUTHOR statement instead. </p>
						</content>
					</section>
					
					
					
					<section id="ResultQuery">
						<title>ResultQuery and various ways of fetching data</title>
						<slogan>
							Various jOOQ query type extend the ResultQuery which provides many means of
							fetching data. In general, fetching means executing and returning some
							sort of result.
						</slogan>
						<content>
							<h2>The ResultQuery provides many convenience methods</h2>
							<pre class="prettyprint lang-java">
public interface ResultQuery&lt;R extends Record&gt; {

  // These methods allow for fetching a jOOQ Result
  // or parts of it.
  // ----------------------------------------------

  // Fetch the whole result
  Result&lt;R&gt; fetch();

  // Fetch a single field from the result
  &lt;T&gt; List&lt;T&gt; fetch(Field&lt;T&gt; field);
      List&lt;?&gt; fetch(int fieldIndex);
      List&lt;?&gt; fetch(String fieldName);

  // Fetch the first Record
  R fetchAny();

  // Fetch exactly one Record
  R fetchOne();

  // Fetch a single field of exactly one Record
  &lt;T&gt; T  fetchOne(Field&lt;T&gt; field);
  Object fetchOne(int fieldIndex);
  Object fetchOne(String fieldName);

  // These methods transform the result into another
  // form, if org.jooq.Result is not optimal
  // -----------------------------------------------

  // Fetch the resulting records as Maps
  List&lt;Map&lt;String, Object&gt;&gt; fetchMaps();
  Map&lt;String, Object&gt; fetchOneMap();

  // Fetch the result as a Map
  &lt;K&gt;    Map&lt;K, R&gt; fetchMap(Field&lt;K&gt; key);
  &lt;K, V&gt; Map&lt;K, V&gt; fetchMap(Field&lt;K&gt; key, Field&lt;V&gt; value);

  // Fetch the resulting records as arrays
  Object[][] fetchArrays();
  Object[] fetchOneArray();

  // Fetch a single field as an array
  &lt;T&gt; T[] fetchArray(Field&lt;T&gt; field);
  Object[] fetchArray(int fieldIndex);
  Object[] fetchArray(String fieldName);

  // These methods transform the result into a user-
  // defined form, if org.jooq.Result is not optimal
  // -----------------------------------------------

  // Fetch the resulting records into a custom POJO
  // type, which may or may not be JPA-annotated
  &lt;E&gt; List&lt;E&gt; fetchInto(Class&lt;? extends E&gt; type);

  // Fetch the resulting records into a custom
  // record handler, similar to how Spring JdbcTemplate's
  // RowMapper or the Ollin Framework works.
  &lt;H extends RecordHandler&lt;R&gt;&gt; H fetchInto(H handler);

  // These change the behaviour of fetching itself,
  // especially, when not all data should be
  // fetched at once
  // ----------------------------------------------

  // Fetch a Cursor for lazy iteration
  Cursor&lt;R&gt; fetchLazy();

  // Fetch data asynchronously and let client code
  // decide, when the data must be available.
  // This makes use of the java.util.concurrent API,
  // Similar to how Avajé Ebean works.
  FutureResult&lt;R&gt; fetchLater();
  FutureResult&lt;R&gt; fetchLater(ExecutorService executor);
}</pre>
						</content>
					</section>
					
					
					<section id="QueryPart">
						<title>QueryParts and the global architecture</title>
						<slogan>When constructing Query objects in jOOQ, everything is
							considered a QueryPart. The purpose of this quickly becomes clear when
							checking out the QueryPart API essentials</slogan>
					</section>
					 
					 
					<section id="Serializability">
						<title>Serializability of QueryParts and Results</title>
						<slogan>Most of the jOOQ API implements the Serializable interface.
							This helps storing queries and partial queries in files, transferring
							queries or result data over TCP/IP, etc. </slogan>
						<content>
							<h2>Attaching QueryParts</h2>
							<p>
								The only transient element in any jOOQ object is the 
								<reference id="Factory"/>'s
								underlying 
								<reference class="java.sql.Connection"/>. When you want to execute queries after
								de-serialisation, or when you want to store/refresh/delete 
								<reference id="UpdatableRecord" title="Updatable Records"/>, 
								you will have to "import" or "re-attach" them to a Factory
							</p>
							<pre class="prettyprint lang-java">
// Deserialise a SELECT statement
ObjectInputStream in = new ObjectInputStream(...);
Select&lt;?&gt; select = (Select&lt;?&gt;) in.readObject();

// This will throw a DetachedException:
select.execute();

// In order to execute the above select, attach it first
Factory create = new Factory(connection, SQLDialect.ORACLE);
create.attach(select);</pre>
					
					
							<h2>Automatically attaching QueryParts</h2>
							<p>In simple cases, you can register a ConfigurationProvider in jOOQ's ConfigurationRegistry</p>
							<pre class="prettyprint lang-java">
// Create your own custom ConfigurationProvider that will make
// your default Factory available to jOOQ
ConfigurationProvider provider = new CustomConfigurationProvider();

// Statically register the provider to jOOQ's ConfigurationRegistry
ConfigurationRegistry.setProvider(provider);</pre>

							<p>Once you have executed these steps, all subsequent deserialisations
								will try to access a Configuration (containing a JDBC Connection) from
								your ConfigurationProvider. This may be useful when </p>
							<ul>
								<li>transporting jOOQ QueryParts or Records via TCP/IP, RMI, etc (e.g.
									between client and server), before immediately executing queries,
									storing UpdatableRecords</li>
								<li>
									Using automatic mechanisms as known in
									<a href="http://wicket.apache.org/">Wicket</a>
								</li>
							</ul>
						</content>
					</section>
					
					
					<section id="Extend">
						<title>Extend jOOQ with custom types</title>
						<slogan>Maybe jOOQ is missing functionality that you would like to see,
							or you can't wait for the next release... In this case, you can extend
							any of the following open jOOQ implementation classes</slogan>
						<content>
							<h2>Write your own QueryPart implementations</h2>
							<p>If a SQL clause is too complex to express with jOOQ, you can extend
								either one of the following types for use directly in a jOOQ query:</p>
							<pre class="prettyprint lang-java">
public abstract class CustomField&lt;T&gt; extends AbstractField&lt;T&gt; {
  // [...]
}
public abstract class CustomCondition extends AbstractCondition {
  // [...]
}</pre>

							<p>These two classes are declared public and covered by integration
								tests. When you extend these classes, you will have to provide your
								own implementations for the <reference id="QueryPart" title="QueryParts"/>' 
								bind(<reference class="org.jooq.BindContext" title="BindContext"/>) and 
								toSQL(<reference class="org.jooq.RenderContext" title="RenderContext"/>) methods:</p>
							<pre class="prettyprint lang-java">
// This method must produce valid SQL. If your QueryPart contains other QueryParts, you may delegate SQL code generation to them
// in the correct order, passing the render context.
//
// If context.inline() is true, you must inline all bind variables
// If context.inline() is false, you must generate ? for your bind variables
public void toSQL(RenderContext context);

// This method must bind all bind variables to a PreparedStatement. If your QueryPart contains other QueryParts, you may delegate
// variable binding to them in the correct order, passing the bind context.
//
// Every QueryPart must ensure, that it starts binding its variables at context.nextIndex().
public void bind(BindContext context) throws SQLException;
</pre>

							<p>The above contract may be a bit tricky to understand at first. The
								best thing is to check out jOOQ source code and have a look at a
								couple of QueryParts, to see how it's done.</p>
							<h2>Plain SQL as an alternative</h2>
							<p>If you don't need integration of rather complex QueryParts into
								jOOQ, then you might be safer using simple 
								<reference id="SQL" title="Plain SQL"/> functionality,
								where you can provide jOOQ with a simple String representation of your
								embedded SQL. </p>
						</content>
					</section>
				</sections>
			</section>
			
			
			
			
			<section id="META">
				<title>Meta model code generation</title>
				<slogan>In these sections you will learn about how to configure and use
					jOOQ's source code generator</slogan>
				<content>
					<h2>Overview</h2>
					<p>
						In the previous chapter, we have seen how to use the 
						<reference id="Factory" title="Factory"/> in order to create 
						<reference id="Query" title="Queries"/> and fetch data in 
						<reference id="Result" title="Results"/>. The strength of jOOQ not
						only lies in its object-oriented 
						<reference id="QueryPart" title="Query model"/>, 
						but also in the fact
						that Java source code is generated from your database schema into the
						META data model. jOOQ follows the paradigm, that your database comes
						first (see also <a href="&lt;?=$root?&gt;/">home page</a>). 
						This means that you should not modify
						generated source code, but only adapt entities in your database. Every
						change in your database is reflected in a corresponding change in your
						generated meta-model.
					</p>
					<p>
						Artefacts, such as tables, views, user defined types, sequences, stored
						procedures, packages have a corresponding artefact in Java.
					</p>
				</content>
				
				
				<sections>
					<section id="Configuration">
						<title>Configuration and setup of the generator</title>
						<slogan>jOOQ uses a simple configuration file to configure source code generation.</slogan>
						<content>
							<h2>The deliverables</h2>
							<p>
								There are three binaries available with jOOQ, to be downloaded from
								<a href="https://sourceforge.net/projects/jooq/">SourceForge</a>
								or from Maven central:
							</p>
							<ul>
								<li>
									<strong>jOOQ.jar</strong>
									<br />
									The main library that you will include in your application to run jOOQ
								</li>
								<li>
									<strong>jOOQ-meta.jar</strong>
									<br />
									The utility that you will include in your build to navigate your
									database schema for code generation. This can be used as a schema
									crawler as well.
								</li>
								<li>
									<strong>jOOQ-codegen.jar</strong>
									<br />
									The utility that you will include in your build to generate your
									database schema
								</li>
							</ul>
							
							<h2>Dependencies</h2>
							<p>All of jOOQ's dependencies are "optional", i.e. you can run
								jOOQ without any of those libraries.
								For instance, jOOQ maintains an "optional" dependency on log4j and slf4j.
								This means, that jOOQ tries to find log4j (and /log4j.xml) or slf4j on the
								classpath. If they are not present, then java.util.logging.Logger is
								used instead.
							</p>
							
							
							<h2>Configure jOOQ</h2>
							<p>You need to tell jOOQ some things about your database connection.
								Here's an example of how to do it for a MySQL database </p>
							<pre class="prettyprint">
#Configure the database connection here
jdbc.Driver=com.mysql.jdbc.Driver
jdbc.URL=jdbc:mysql://[your jdbc URL]
jdbc.Schema=[your database schema]
jdbc.User=[your database user]
jdbc.Password=[your database password]

#The default code generator. You can override this one, to generate your own code style
#Defaults to org.jooq.util.DefaultGenerator
generator=org.jooq.util.DefaultGenerator

#The database type. The format here is:
#generator.database=org.util.[database].[database]Database
generator.database=org.jooq.util.mysql.MySQLDatabase

#All elements that are generated from your schema (several Java regular expressions, separated by comma)
#Watch out for case-sensitivity. Depending on your database, this might be important!
generator.database.includes=.*

#All elements that are excluded from your schema (several Java regular expressions, separated by comma). Excludes match before includes
generator.database.excludes=

#Primary key / foreign key relations should be generated and used. 
#This will be a prerequisite for various advanced features
#Defaults to false
generator.generate.relations=true

#Generate deprecated code for backwards compatibility 
#Defaults to true
generator.generate.deprecated=false

#The destination package of your generated classes (within the destination directory)
generator.target.package=[org.jooq.your.package]

#The destination directory of your generated classes
generator.target.directory=[/path/to/your/dir]</pre>

							<p>And you can add some optional advanced configuration parameters: </p>
							<pre class="prettyprint">
#Generate a master data table enum classes (several Java regular expressions, separated by comma)
generator.generate.master-data-tables=[a list of tables]

#For every master data table, specify two special columns
generator.generate.master-data-table-literal.[master data table]=[column used for enum literals]
generator.generate.master-data-table-description.[master data table]=[column used for documentation]</pre>
							<p>Check out the manual's section about 
								<reference id="MasterData" title="master data"/>
								 to find out more
								about those advanced configuration parameters. </p>
								
							<h2>Run jOOQ code generation</h2>
							<p>Code generation works by calling this class with the above property file as argument.</p>
							<pre class="prettyprint">
org.jooq.util.GenerationTool /jooq-config.properties</pre>
							<p>Be sure that these elements are located on the classpath: </p>
							<ul>
								<li>The property file</li>
								<li>jooq.jar, jooq-meta.jar, jooq-codegen.jar</li>
								<li>The JDBC driver you configured</li>
							</ul>
							
							<h3>A command-line example (For Windows, unix/linux/etc will be similar)</h3>
							<ul>
								<li>Put the property file, jooq*.jar and the JDBC driver into 
									a directory, e.g. C:\temp\jooq</li>
							    <li>Go to C:\temp\jooq</li>
							    <li>Run java -cp jooq.jar;jooq-meta.jar;jooq-codegen.jar;[JDBC-driver].jar;. org.jooq.util.GenerationTool /[property file] </li>
							</ul>
							<p>Note that the property file must be passed as a classpath resource</p>
							
							<h3>Run code generation from Eclipse</h3>
							<p>Of course, you can also run code generation from your IDE. In
								Eclipse, set up a project like this. Note that this example uses
								jOOQ's log4j support by adding log4j.xml and log4j.jar to the project
								classpath: </p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-01.png" alt="Eclipse configuration"/>
							</div>
							
							<p>Once the project is set up correctly with all required artefacts on
								the classpath, you can configure an Eclipse Run Configuration for
								org.jooq.util.GenerationTool. </p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-02.png" alt="Eclipse configuration"/>
							</div>
							
							<p>With the properties file as an argument </p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-03.png" alt="Eclipse configuration"/>
							</div>
							
							<p>And the classpath set up correctly</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-04.png" alt="Eclipse configuration"/>
							</div>
							
							<p>Finally, run the code generation and see your generated artefacts</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-05.png" alt="Eclipse configuration"/>
							</div>
							
							<h3>Run generation with ant</h3>
							<p>You can also use an ant task to generate your classes: </p>
							<pre class="prettyprint lang-xml">
&lt;!-- Task definition --&gt;
&lt;taskdef name="generate-classes" classname="org.jooq.util.GenerationTask"&gt;
  &lt;classpath&gt;
    &lt;fileset dir="${path.to.jooq.distribution}"&gt;
      &lt;include name="jOOQ.jar"/&gt;
      &lt;include name="jOOQ-meta.jar"/&gt;
      &lt;include name="jOOQ-codegen.jar"/&gt;
    &lt;/fileset&gt;
    &lt;fileset dir="${path.to.mysql.driver}"&gt;
      &lt;include name="${mysql.driver}.jar"/&gt;
    &lt;/fileset&gt;
  &lt;/classpath&gt;
&lt;/taskdef&gt;

&lt;!-- Run the code generation task --&gt;
&lt;target name="generate-test-classes"&gt;
  &lt;generate-classes 
      jdbcurl="jdbc:mysql://localhost/test"
      jdbcschema="test"
      jdbcuser="root"
      jdbcpassword=""
      generatortargetpackage="org.jooq.test.generatedclasses"
      generatortargetdirectory="${basedir}/src"/&gt;
&lt;/target&gt;</pre>
							
							<h3>Use jOOQ generated classes in your application</h3>
							<p>Be sure, both jOOQ.jar and your generated package (see
								configuration) are located on your classpath. Once this is done, you
								can execute SQL statements with your generated classes.</p>
						</content>
					</section>
					
					
					<section id="SCHEMA">
						<title>The schema, top-level generated artefact</title>
						<slogan>The schema is the top-level generated object in jOOQ. In many 
							RDBMS, the schema coincides with the owner of tables and other objects
						</slogan>
						<content>
							<h2>The Schema</h2>
							<p>
								As of jOOQ 1.5, the top-level generated object is the
								<reference class="org.jooq.Schema" />.
								The Schema itself has no relevant functionality, except for holding
								the schema name for all dependent generated artefacts. jOOQ queries try
								to always fully qualify an entity within the database using that Schema
							</p>
							
							<p>
								Currently, it is not possible to link generated artefacts from various
								schemata. If you have a stored function from Schema A, which returns a
								UDT from Schema B, the types cannot be linked. This enhancement is on
								the roadmap, though: <reference ticket="282"/>.
							</p>
							
							<p>
								When you have several schemata that are logically equivalent (i.e. they
								contain identical entities, but the schemata stand for different
								users/customers/clients, etc), there is a solution for that. Check out
								the manual's section on support for 
								<reference id="SchemaMapping" title="multiple equivalent schemata"/> 
							</p>

							<h3>Schema contents</h3>
							<p>The schema can be used to dynamically discover generate database
								artefacts. Tables, sequences, and other items are accessible from the
								schema. For example:</p>
							<pre class="prettyprint lang-java">
public final java.util.List&lt;org.jooq.Sequence&gt; getSequences();
public final java.util.List&lt;org.jooq.Table&lt;?&gt;&gt; getTables();</pre>
						</content>
					</section>
					
					
					<section id="TABLE">
						<title>Tables, views and their corresponding records</title>
						<slogan>
							The most important generated artefacts are Tables and TableRecords.
							Every Table has a Record type associated with it that models a single tuple
							of that entity: Table&lt;R extends Record&gt;.
						</slogan>
						<content>
							<h2>Tables and TableRecords</h2>
							<p>
								The most important generated artefacts are 
								<reference class="org.jooq.Table" title="Tables"/> and 
								<reference class="org.jooq.TableRecord" title="TableRecords"/>. As
								discussed in previous chapters about 
								<reference id="Table" title="Tables"/> and 
								<reference id="Result" title="Results"/>, jOOQ uses the
								Table class to model entities (both tables and views) in your database
								Schema. Every Table has a Record type associated with it that models a
								single tuple of that entity: Table&lt;R extends Record&gt;. This
								couple of Table&lt;R&gt; and R are generated as such:
							</p>
							<p>
								Suppose we have the tables as defined in the 
								<reference id="ExampleDatabase" title="example database"/>. 
								Then, using a
								default configuration, these (simplified for the example) classes will
								be generated:
							</p>
							
							<h3>The Table as an entity meta model</h3>
							<pre class="prettyprint lang-java">
public class TAuthor extends UpdatableTableImpl&lt;TAuthorRecord&gt; {

    // The singleton instance of the Table
    public static final TAuthor T_AUTHOR = new TAuthor();

    // The Table's fields    
    public static final TableField&lt;TAuthorRecord, Integer&gt; ID =            // [...]
    public static final TableField&lt;TAuthorRecord, String&gt; FIRST_NAME =     // [...]
    public static final TableField&lt;TAuthorRecord, String&gt; LAST_NAME =      // [...]
    public static final TableField&lt;TAuthorRecord, Date&gt; DATE_OF_BIRTH =    // [...]
    public static final TableField&lt;TAuthorRecord, Integer&gt; YEAR_OF_BIRTH = // [...]
}</pre>

							<h3>The Table's associated TableRecord</h3>
							<p>If you use the 
								<reference id="Query" title="SimpleSelectQuery"/>
								 syntax (both in standard and DSL
								mode), then your SELECT statement will return the single Table&lt;R
								extends Record&gt;'s associated Record type &lt;R&gt;. In the case of
								the above TAuthor Table, this will be a TAuthorRecord. </p>
								
							<pre class="prettyprint lang-java">
public class TAuthorRecord extends UpdatableRecordImpl&lt;TAuthorRecord&gt; {

    // Getters and setters for the various fields
    public void setId(Integer value) {       // [...]
    public Integer getId() {                 // [...]
    public void setFirstName(String value) { // [...]
    public String getFirstName() {           // [...]
    public void setLastName(String value) {  // [...]
    public String getLastName() {            // [...]
    public void setDateOfBirth(Date value) { // [...]
    public Date getDateOfBirth() {           // [...]

    // Navigation methods for foreign keys
    public List&lt;TBookRecord&gt; getTBooks() throws SQLException { // [...]
}</pre>
						</content>
					</section>
					
					
					<section id="PROCEDURE">
						<title>Procedures and packages</title>
						<slogan>
							Procedure support is one of the most important reasons why you should consider
							jOOQ. jOOQ heavily facilitates the use of stored procedures and
							functions via its source code generation.
						</slogan>
						<content>
							<h2>Stored procedures in modern RDBMS</h2>
							<p>This is one of the most important reasons why you should consider
								jOOQ. Read also my 
								<a href="http://java.dzone.com/articles/2011-great-year-stored" title="Article on stored procedures and how to use them with jOOQ">article on dzone</a>
								about why stored procedures become
								more and more important in future versions of RDMBS. In this section
								of the manual, we will learn how jOOQ handles stored procedures in
								code generation. Especially before 
								<reference id="UDT" title="UDT and ARRAY support"/> was
								introduced to major RDBMS, these procedures tend to have dozens of
								parameters, with IN, OUT, IN OUT parameters mixed in all variations.
								JDBC only knows very basic, low-level support for those constructs.
								jOOQ heavily facilitates the use of stored procedures and functions
								via its source code generation. Essentially, it comes down to this:
							</p>
							
							<h3>"Standalone" stored procedures and functions</h3>
							<p>Let's say you have these stored procedures and functions in your Oracle database </p>
							<pre class="prettyprint lang-sql">
-- Check whether there is an author in T_AUTHOR by that name
CREATE OR REPLACE FUNCTION f_author_exists (author_name VARCHAR2) RETURN NUMBER;

-- Check whether there is an author in T_AUTHOR by that name
CREATE OR REPLACE PROCEDURE p_author_exists (author_name VARCHAR2, result OUT NUMBER);

-- Check whether there is an author in T_AUTHOR by that name and get his ID
CREATE OR REPLACE PROCEDURE p_author_exists_2 (author_name VARCHAR2, result OUT NUMBER, id OUT NUMBER);</pre>
							
							<p>jOOQ will essentially generate two artefacts for every procedure/function: </p>
							<ul>
								<li>A class holding a formal Java representation of the procedure/function</li>
    							<li>Some convenience methods to facilitate calling that procedure/function </li>
							</ul>
							<p>Let's see what these things look like, in Java. The classes (simplified for the example): </p>
							
							<pre class="prettyprint lang-java">
// The function has a generic type parameter &lt;T&gt; bound to its return value
public class FAuthorExists extends StoredFunctionImpl&lt;BigDecimal&gt; {

    // Much like Tables, functions have static parameter definitions
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]

    // And much like TableRecords, they have setters for their parameters
    public void setAuthorName(String value) { // [...]
    public void setAuthorName(Field&lt;String&gt; value) { // [...]
}

public class PAuthorExists extends StoredProcedureImpl {

    // In procedures, IN, OUT, IN OUT parameters are all represented
    // as static parameter definitions as well
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]
    public static final Parameter&lt;BigDecimal&gt; RESULT = // [...]

    // IN and IN OUT parameters have generated setters
    public void setAuthorName(String value) { // [...]

    // OUT and IN OUT parameters have generated getters
    public BigDecimal getResult() { // [...]
}

public class PAuthorExists_2 extends StoredProcedureImpl {
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]
    public static final Parameter&lt;BigDecimal&gt; RESULT = // [...]
    public static final Parameter&lt;BigDecimal&gt; ID = // [...]

    // the setters...
    public void setAuthorName(String value) { // [...]

    // the getters...
    public BigDecimal getResult() { // [...]
    public BigDecimal getId() { // [...]
}</pre>

							<p>An example invocation of such a stored procedure might look like this: </p>
							
							<pre class="prettyprint lang-java">
PAuthorExists p = new PAuthorExists();
p.setAuthorName("Paulo");
p.execute(configuration);
assertEquals(BigDecimal.ONE, p.getResult());</pre>

							<p>If you use the generated convenience methods, however, things are much simpler, still: </p>
							<pre class="prettyprint lang-java">
// Every schema has a single Functions class with convenience methods
public final class Functions {

    // Convenience method to directly call the stored function
    public static BigDecimal fAuthorExists(Configuration configuration, String authorName) { // [...]

    // Convenience methods to transform the stored function into a
    // Field&lt;BigDecimal&gt;, such that it can be used in SQL
    public static Field&lt;BigDecimal&gt; fAuthorExists(Field&lt;String&gt; authorName) { // [...]
    public static Field&lt;BigDecimal&gt; fAuthorExists(String authorName) { // [...]
}

// Every schema has a single Procedures class with convenience methods
public final class Procedures {

    // Procedures with 0 OUT parameters create void methods
    // Procedures with 1 OUT parameter create methods as such:
    public static BigDecimal pAuthorExists(Configuration configuration, String authorName) { // [...]

    // Procedures with more than 1 OUT parameter return the procedure
    // object (see above example)
    public static PAuthorExists_2 pAuthorExists_2(Configuration configuration, String authorName) { // [...]
}</pre>

							<p>An sample invocation, equivalent to the previous example:</p>
							<pre class="prettyprint lang-java">
assertEquals(BigDecimal.ONE, Procedures.pAuthorExists(configuration, "Paulo"));</pre>


							<h3>jOOQ's understanding of procedures vs functions</h3>
							<p>
								It might not be very clear, what defines a procedure and what
								defines a
								function in those RDBMS that support these objects. Most
								often, a function
								has a mandatory return value, whereas procedures can
								return OUT parameters.
								Oracle allows for mixing those concepts.
								Postgres omits the term procedure, etc.
							</p>
							<p>
								For jOOQ, the following applies:
							</p>
							<ul>
								<li>
									A procedure is an object that cannot be used in SQL (because it
									has no
									return value). A procedure is called internally by jOOQ using a
									<reference class="java.sql.CallableStatement" />
								</li>
								<li>
									A function is an object that can be used in SQL. There is always
									the
									possibility to create a
									<reference class="org.jooq.Field" />
									to represent the function
									embedded in SQL.
								</li>
							</ul>
							
							
							<h3>Packages in Oracle</h3>
							<p>
								Oracle uses the concept of a PACKAGE to group several
								procedures/functions into a sort of namespace. The
								<a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt"
									title="SQL 92 standard">SQL standard</a>
								talks about "modules", to represent this concept, even if this is
								rarely implemented. This is reflected in jOOQ by the use of Java
								sub-packages in the source code generation destination package. Every
								Oracle package will be reflected by
							</p>
							<ul>
								<li>A Java package holding classes for formal Java representations of
									the procedure/function in that package
								</li>
								<li>A Java class holding convenience methods to facilitate calling
									those procedures/functions
								</li>
							</ul>
							<p>
								Apart from this, the generated source code looks exactly like the
								one for
								standalone procedures/functions.
							</p>
						</content>
					</section>
					
					
					<section id="UDT">
						<title>UDT's including ARRAY and ENUM types</title>
						<slogan>
							Databases become more powerful when you can structure your data in user
							defined types. It's time for Java developers to give some credit to
							that.
						</slogan>
						<content>
							<h2>Increased RDBMS support for UDT's</h2>
							<p>
								In recent years, most RDBMS have started to implement some support for
								advanced data types. This support has not been adopted very well by
								database users in the Java world, for several reasons: 
							</p>
							<ul>
								<li>They are usually orthogonal to relational concepts. It is not easy
									to modify a UDT once it is referenced by a table column.</li>
								<li>There is little standard support of accessing them from JDBC (and
									probably other database connectivity standards). </li>
							</ul>
							<p>
								On the other hand, especially with stored procedures, these data types
								are likely to become more and more useful in the future. If you have a
								look at Postgres' capabilities of dealing with advanced data types
								(<a href="http://www.postgresql.org/docs/9.0/interactive/datatype-enum.html">ENUMs</a>,
								<a href="http://www.postgresql.org/docs/9.0/interactive/arrays.html">ARRAYs</a>,
								<a href="http://www.postgresql.org/docs/9.0/interactive/rowtypes.html">UDT's</a>),
								 this becomes more and more obvious.
							</p>
							<p>It is a central strategy for jOOQ, to standardise access to these
								kinds of types (as well as to 
								<reference id="PROCEDURE" title="stored procedures"/>, of course) across all
								RDBMS, where these types are supported. </p>
								
							<h2>UDT types</h2>
							<p>User Defined Types (UDT) are helpful in major RDMBS with lots
							of proprietary functionality. The biggest player is clearly Oracle.
							Currently, jOOQ provides UDT support for only two databases: </p>
							<ul>
								<li>Oracle</li>
								<li>Postgres</li>
							</ul>
							<p>Apart from that, </p>
							<ul>
								<li>
									DB2 UDT's are not supported as they are very tough to
									serialise/deserialise. We don't think that this is a big enough
									requirement to put more effort in those, right now (see also the
									developers' discussion on
									<reference ticket="164" />)
								</li>
							</ul>
							
							<p>In Oracle, you would define UDTs like this: </p>
							<pre class="prettyprint lang-sql">
CREATE TYPE u_street_type AS OBJECT (
  street VARCHAR2(100),
  no VARCHAR2(30)
)

CREATE TYPE u_address_type AS OBJECT (
  street u_street_type,
  zip VARCHAR2(50),
  city VARCHAR2(50),
  country VARCHAR2(50),
  since DATE,
  code NUMBER(7)
)</pre>

							<p>These types could then be used in tables and/or stored procedures like such: </p>
							<pre class="prettyprint lang-sql">
CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  -- [...]
  address u_address_type
)

CREATE OR REPLACE PROCEDURE p_check_address (address IN OUT u_address_type);</pre>

							<p>
								Standard JDBC UDT support encourages JDBC-driver developers to implement
								interfaces such as 
								<reference class="java.sql.SQLData"/>, 
								<reference class="java.sql.SQLInput"/> and
								<reference class="java.sql.SQLOutput"/>. 
								Those interfaces are non-trivial to implement, or
								to hook into. Also access to 
								<reference class="java.sql.Struct"/> 
								is not really simple. Due
								to the lack of a well-defined JDBC standard, Oracle's JDBC driver
								rolls their own proprietary methods of dealing with these types. jOOQ
								goes a different way, it hides those facts from you entirely. With
								jOOQ, the above UDT's will be generated in simple 
								<reference class="org.jooq.UDT" title="UDT meta-model classes"/> and 
								<reference class="org.jooq.UDTRecord" title="UDT record classes"/> as such:
							</p>
							<pre class="prettyprint lang-java">
// There is an analogy between UDT/Table and UDTRecord/TableRecord...
public class UAddressType extends UDTImpl&lt;UAddressTypeRecord&gt; {

    // The UDT meta-model singleton instance
    public static final UAddressType U_ADDRESS_TYPE = new UAddressType();

    // UDT attributes are modeled as static members. Nested UDT's
    // behave similarly
    public static final UDTField&lt;UAddressTypeRecord, UStreetTypeRecord&gt; STREET = // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; ZIP =               // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; CITY =              // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; COUNTRY =           // [...]
    public static final UDTField&lt;UAddressTypeRecord, Date&gt; SINCE =               // [...]
    public static final UDTField&lt;UAddressTypeRecord, Integer&gt; CODE =             // [...]
}</pre>

							<p>Now, when you interact with entities or procedures that hold UDT's, that's very simple as well. Here is an example: </p>
							<pre class="prettyprint lang-java">
// Fetch any author from the T_AUTHOR table
TAuthorRecord author = create.selectFrom(T_AUTHOR).fetchAny();

// Print out the author's address's house number
System.out.println(author.getAddress().getStreet().getNo());</pre>

							<p>A similar thing can be achieved when interacting with the example stored procedure: </p>
							<pre class="prettyprint lang-java">
// Create a new UDTRecord of type U_ADDRESS_TYPE
UAddressTypeRecord address = new UAddressTypeRecord();
address.setCountry("Switzerland");

// Call the stored procedure with IN OUT parameter of type U_ADDRESS_TYPE
address = Procedures.pCheckAddress(connection, address);</pre>


							<h2>ARRAY types</h2>
							<p>
								The notion of ARRAY types in RDBMS is not standardised at all. Very
								modern databases (especially the Java-based ones) have implemented
								ARRAY types exactly as what they are. "ARRAYs of something". In other
								words, an ARRAY OF VARCHAR would be something very similar to Java's
								notion of String[]. An ARRAY OF ARRAY OF VARCHAR would then be a
								String[][] in Java. Some RDMBS, however, enforce stronger typing and
								need the explicit creation of types for every ARRAY as well. These are
								example String[] ARRAY types in various SQL dialects supported by jOOQ
								1.5.4:
							</p>
							<ul>
								<li>Oracle: VARRAY OF VARCHAR2. A strongly typed object encapsulating an ARRAY of a given type. See the <a href="http://download.oracle.com/docs/cd/B19306_01/appdev.102/b14261/collection_definition.htm">documentation.</a></li>
								<li>Postgres: text[]. Any data type can be turned into an array by suffixing it with []. See the <a href="http://www.postgresql.org/docs/9.0/interactive/arrays.html">documentation</a></li>
								<li>HSQLDB: VARCHAR ARRAY. Any data type can be turned into an array by suffixing it with ARRAY. See the <a href="http://hsqldb.org/doc/2.0/guide/sqlgeneral-chapt.html#N1070F">documentation</a></li>
								<li>H2: ARRAY. H2 does not know of typed arrays. All ARRAYs are mapped to Object[]. See the <a href="http://www.h2database.com/html/datatypes.html#array_type">documentation</a></li>
							</ul>
							<p>Soon to be supported: </p>
							<ul>
								<li>DB2: Knows a similar strongly-typed ARRAY type, like Oracle </li>
							</ul>
							<p>
								From jOOQ's perspective, the ARRAY types fit in just like any other
								type wherever the
								&lt;T&gt; generic type parameter is existent. It integrates well with tables
									and stored procedures.
							</p>
							
							<h3>Example: General ARRAY types</h3>
							<p>An example usage of ARRAYs is given here for the Postgres dialect </p>
							
							<pre class="prettyprint lang-sql">
CREATE TABLE t_arrays (
  id integer not null primary key,
  string_array VARCHAR(20)[],
  number_array INTEGER[]
)

CREATE FUNCTION f_arrays(in_array IN text[]) RETURNS text[]</pre>

							<p>When generating source code from the above entities, these artefacts will be created in Java: </p>
							<pre class="prettyprint lang-java">
public class TArrays extends UpdatableTableImpl&lt;TArraysRecord&gt; {

    // The generic type parameter &lt;T&gt; is bound to an array of a matching type
    public static final TableField&lt;TArraysRecord, String[]&gt; STRING_ARRAY =  // [...]
    public static final TableField&lt;TArraysRecord, Integer[]&gt; NUMBER_ARRAY = // [...]
}

// The convenience class is enhanced with these methods
public final class Functions {
    public static String[] fArrays(Connection connection, String[] inArray) throws SQLException { // [...]
    public static Field&lt;String[]&gt; fArrays(String[] inArray) {                                     // [...]
    public static Field&lt;String[]&gt; fArrays(Field&lt;String[]&gt; inArray) {                              // [...]
}</pre>

							<h3>Example: Oracle VARRAY types</h3>
							<p>In Oracle, a VARRAY type is something slightly different than in
								other RDMBS. It is a type that encapsules the actual ARRAY and creates
								a new type from it. While all text[] types are equal and thus
								compatible in Postgres, this does not apply for all VARRAY OF VARCHAR2
								types. Hence, it is important to provide access to VARRAY types and
								generated objects from those types as well. The example above would
								read like this in Oracle: </p>
								
							<pre class="prettyprint lang-sql">
CREATE TYPE u_string_array AS VARRAY(4) OF VARCHAR2(20)
CREATE TYPE u_number_array AS VARRAY(4) OF NUMBER(7)

CREATE TABLE t_arrays (
  id NUMBER(7) not null primary key,
  string_array u_string_array,
  number_array u_number_array
)

CREATE OR REPLACE FUNCTION f_arrays (in_array u_string_array)
RETURN u_string_array</pre>

							<p>Note that it becomes clear immediately, that a mapping from
								U_STRING_ARRAY to String[] is obvious. But a mapping from String[] to
								U_STRING_ARRAY is not. These are the generated 
								<reference class="org.jooq.ArrayRecord" /> and other
								artefacts in Oracle: </p>
								
							<pre class="prettyprint lang-java">
public class UStringArrayRecord extends ArrayRecordImpl&lt;String&gt; {  // [...]
public class UNumberArrayRecord extends ArrayRecordImpl&lt;Integer&gt; { // [...]

public class TArrays extends UpdatableTableImpl&lt;TArraysRecord&gt; {
    public static final TableField&lt;TArraysRecord, UStringArrayRecord&gt; STRING_ARRAY = // [...]
    public static final TableField&lt;TArraysRecord, UNumberArrayRecord&gt; NUMBER_ARRAY = // [...]
}

public final class Functions {
    public static UStringArrayRecord fArrays3(Connection connection, UStringArrayRecord inArray) { // [...]
    public static Field&lt;UStringArrayRecord&gt; fArrays3(UStringArrayRecord inArray) {                 // [...]
    public static Field&lt;UStringArrayRecord&gt; fArrays3(Field&lt;UStringArrayRecord&gt; inArray) {          // [...]
}</pre>

							
							<h2>ENUM types</h2>
							<p>True ENUM types are a rare species in the RDBMS world. Currently,
								MySQL and Postgres are the only RDMBS supported by jOOQ, that provide
								ENUM types. </p>
								
							<ul>
								<li>In MySQL, an ENUM type is declared directly upon a column. It cannot be reused as a type. See the <a href="http://dev.mysql.com/doc/refman/5.5/en/enum.html">documentation.</a> </li>
								<li>In Postgres, the ENUM type is declared independently and can be reused among tables, functions, etc. See the <a href="http://www.postgresql.org/docs/9.0/interactive/datatype-enum.html">documentation.</a> </li>
								<li>Other RDMBS know about "ENUM constraints", such as the Oracle CHECK constraint. These are not true ENUMS, however. jOOQ refrains from using their information for source code generation </li>
							</ul>
							
							<p>Some examples: </p>
							<pre class="prettyprint lang-sql">
-- An example enum type
CREATE TYPE u_book_status AS ENUM ('SOLD OUT', 'ON STOCK', 'ORDERED')

-- An example useage of that enum type
CREATE TABLE t_book (
  id INTEGER NOT NULL PRIMARY KEY,

  -- [...]
  status u_book_status
)</pre>

							<p>The above Postgres ENUM type will be generated as </p>
							<pre class="prettyprint lang-java">
public enum UBookStatus implements EnumType {
    ORDERED("ORDERED"),
    ON_STOCK("ON STOCK"),
    SOLD_OUT("SOLD OUT");

    // [...]
}</pre>
							<p>Intuitively, the generated classes for the T_BOOK table in Postgres would look like this: </p>
							<pre class="prettyprint lang-sql">
// The meta-model class
public class TBook extends UpdatableTableImpl&lt;TBookRecord&gt; {

    // The TableField STATUS binds &lt;T&gt; to UBookStatus
    public static final TableField&lt;TBookRecord, UBookStatus&gt; STATUS = // [...]

    // [...]
}

// The record class
public class TBookRecord extends UpdatableRecordImpl&lt;TBookRecord&gt; {

    // Corresponding to the Table meta-model, also setters and getters
    // deal with the generated UBookStatus
    public void setStatus(UBookStatus value) { // [...]
    public UBookStatus getStatus() {           // [...]
}</pre>

							<p>Note that jOOQ allows you to simulate ENUM types where this makes
								sense in your data model. See the section on 
								<reference id="MasterData" title="master data"/> for more
								details. </p>
						</content>
					</section>
					
					
					<section id="SEQUENCE">
						<title>Sequences</title>
						<slogan>
							jOOQ also generates convenience artefacts for sequences, where this is
							supported: DB2, Derby, H2, HSQLDB, Oracle, Postgres, and more. 
						</slogan>
						<content>
							<h2>Sequences as a source for identity values</h2>
							<p> Sequences implement the 
							<reference class="org.jooq.Sequence"/> interface, providing essentially this functionality:</p>
							
							<pre class="prettyprint lang-java">
// Get a field for the CURRVAL sequence property
Field&lt;BigInteger&gt; currval();

// Get a field for the NEXTVAL sequence property
Field&lt;BigInteger&gt; nextval();</pre>		
							<p>So if you have a sequence like this in Oracle: </p>
							<pre class="prettyprint lang-sql">CREATE SEQUENCE s_author_id</pre>		
							<p>This is what jOOQ will generate: </p>	
							<pre class="prettyprint lang-java">
public final class Sequences {

    // A static sequence instance
    public static final Sequence S_AUTHOR_ID = // [...]
}</pre>		

							<p>Which you can use in a select statement as such: </p>
							<pre class="prettyprint lang-java">
Field&lt;BigInteger&gt; s = Sequences.S_AUTHOR_ID.nextval();
BigInteger nextID   = create.select(s).fetchOne(s);</pre>

							<p>Or directly fetch currval() and nextval() from the sequence using the Factory: </p>
							<pre class="prettyprint lang-java">
BigInteger currval = create.currval(Sequences.S_AUTHOR_ID);
BigInteger nextval = create.nextval(Sequences.S_AUTHOR_ID);</pre>
						</content>
					</section>
				</sections>
			</section>
			
			
			
			
			<section id="DSL">
				<title>DSL or fluent API. Where SQL meets Java</title>
				<slogan>
				</slogan>
				<content>
					<p>jOOQ ships with its own DSL (or Domain Specific Language) that
						simulates SQL as good as possible in Java. This means, that you can
						write SQL statements almost as if Java natively supported that syntax
						just like .NET's C# does with <a href="http://msdn.microsoft.com/en-us/library/bb425822.aspx">LINQ to SQL.</a></p>
						
					<p>Here is an example to show you what that means. When you want to write a query like this in SQL: </p>
					<table width="100%" cellpadding="0" cellspacing="0">
						<tr>
							<td width="50%">Here is an example to show you what that means. When you want to write a query like this in SQL: </td>
							<td width="50%">Then, using jOOQ's DSL API, you can write the same query as such: </td>
						</tr>
						<tr>
							<td width="50%" class="left"><pre class="prettyprint lang-sql">
-- Select all books by authors born after 1920, 
-- named "Paulo" from a catalogue:
SELECT * 
  FROM t_author a 
  JOIN t_book b ON a.id = b.author_id 
 WHERE a.year_of_birth &gt; 1920 
   AND a.first_name = 'Paulo'
 ORDER BY b.title</pre></td>
								<td width="50%" class="right"><pre class="prettyprint lang-java">
Result&lt;Record&gt; result = 
create.select()
      .from(T_AUTHOR)
      .join(T_BOOK).on(TAuthor.ID.equal(TBook.AUTHOR_ID))
      .where(TAuthor.YEAR_OF_BIRTH.greaterThan(1920)
      .and(TAuthor.FIRST_NAME.equal("Paulo")))
      .orderBy(TBook.TITLE)
      .fetch();</pre></td>
						</tr>
					</table>
					
					<p>You couldn't come much closer to SQL itself in Java, without re-writing the compiler. </p>
				</content>
				
				
				<sections>
					<section id="SELECT">
						<title>Complete SELECT syntax</title>
						<slogan>
							A SELECT statement is more than just the R in CRUD. It allows for
							transforming your relational data into any other form using concepts
							such as equi-join, semi-join, anti-join, outer-join and much more. jOOQ
							helps you think in precisely those relational concepts.
						</slogan>
						<content>
							<h2>SELECT from anonymous or ad-hoc types</h2>
							<p>When you don't just perform CRUD (i.e. SELECT * FROM your_table WHERE ID = ?),
							you're usually generating new types using custom projections. With jOOQ, this is
							as intuitive, as if using SQL directly. A more or less complete example of the "standard" SQL syntax, plus
							some extensions, is provided by a query like this:
							</p>
							
							<pre class="prettyprint lang-sql">
-- get all authors' first and last names, and the number 
-- of books they've written in German, if they have written
-- more than five books in German in the last three years 
-- (from 2011), and sort those authors by last names
-- limiting results to the second and third row, locking
-- the rows for a subsequent update... whew!

  SELECT T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, COUNT(*)
    FROM T_AUTHOR
    JOIN T_BOOK ON T_AUTHOR.ID = T_BOOK.AUTHOR_ID
   WHERE T_BOOK.LANGUAGE = 'DE'
     AND T_BOOK.PUBLISHED > '2008-01-01'
GROUP BY T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME
  HAVING COUNT(*) > 5
ORDER BY T_AUTHOR.LAST_NAME ASC NULLS FIRST
   LIMIT 2 
  OFFSET 1
     FOR UPDATE</pre>			
     
     						<p>So that's daily business. How to do it with jOOQ: When you first create a SELECT statement using the Factory's select() methods </p>
     						<pre class="prettyprint lang-java">
SelectFromStep select(Field&lt;?&gt;... fields);

// Example:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count());</pre>

							<p>
								jOOQ will return an "intermediary" type to you, representing the
								SELECT statement about to be created (by the way, check out the
								section on <reference id="FUNCTIONS" title="aggregate operators"/>
								 to learn more about the COUNT(*)
								function). This type is the 
								<reference class="org.jooq.SelectFromStep"/>. 
								When you have a reference
								to this type, you may add a FROM clause, although that clause is
								optional. This is reflected by the fact, that the SelectFromStep type
								extends 
								<reference class="org.jooq.SelectJoinStep"/>, 
								which allows for adding the subsequent
								clauses. Let's say you do decide to add a FROM clause, then you can
								use this method for instance:
							</p>			
							<pre class="prettyprint lang-java">
SelectJoinStep from(TableLike&lt;?&gt;... table);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR);</pre>

							<p>After adding the table-like structures (mostly just Tables) to
								select from, you may optionally choose to add a JOIN clause, as the
								type returned by jOOQ is the step where you can add JOINs. Again,
								adding these clauses is optional, as the 
								<reference class="org.jooq.SelectJoinStep"/> extends
								<reference class="org.jooq.SelectWhereStep"/>. 
								But let's say we add a JOIN: </p>
							<pre class="prettyprint lang-java">
// These join types are supported
SelectOnStep                    join(Table&lt;?&gt; table);
SelectOnStep           leftOuterJoin(Table&lt;?&gt; table);
SelectOnStep          rightOuterJoin(Table&lt;?&gt; table);
SelectOnStep           fullOuterJoin(Table&lt;?&gt; table);
SelectJoinStep             crossJoin(Table&lt;?&gt; table);
SelectJoinStep           naturalJoin(Table&lt;?&gt; table);
SelectJoinStep  naturalLeftOuterJoin(Table&lt;?&gt; table);
SelectJoinStep naturalRightOuterJoin(Table&lt;?&gt; table);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK);</pre>

							<p>Now, if you do add a JOIN clause, you have to specify the JOIN .. ON
								condition before you can add more clauses. That's not an optional step
								for some JOIN types. This is reflected by the fact that 
								<reference class="org.jooq.SelectOnStep"/>
								is a top-level interface. </p>
								
							<pre class="prettyprint lang-java">
// These join conditions are supported
SelectJoinStep    on(Condition... conditions);
SelectJoinStep using(Field&lt;?&gt;... fields);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(TBook.AUTHOR_ID.equal(TAuthor.ID));</pre>

							<p>See the section about 
								<reference id="CONDITION" title="Conditions"/> 
								to learn more about the many ways
								to create Conditions in jOOQ. Now we're half way through. As you can
								see above, we're back to the SelectJoinStep. This means, we can
								re-iterate and add another JOIN clause, just like in SQL. Or we go on
								to the next step, adding conditions in the 
								<reference class="org.jooq.SelectWhereStep"/>: </p>
							<pre class="prettyprint lang-java">
SelectConditionStep where(Condition... conditions);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(TBook.AUTHOR_ID.equal(TAuthor.ID))
      .where(TBook.LANGUAGE.equal("DE"));</pre>

							<p>Now the returned type 
								<reference class="org.jooq.SelectConditionStep"/> is a special one, where
								you can add more conditions to the already existing WHERE clause.
								Every time you add a condition, you will return to that
								SelectConditionStep, as the number of additional conditions is
								unlimited. Note that of course you can also just add a single combined
								condition, if that is more readable or suitable for your use-case.
								Here's how we add another condition: </p>
							<pre class="prettyprint lang-java">
SelectConditionStep and(Condition condition);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(TBook.AUTHOR_ID.equal(TAuthor.ID))
      .where(TBook.LANGUAGE.equal("DE"))
      .and(TBook.PUBLISHED.greaterThan(parseDate('2008-01-01')));</pre>

							<p>Let's assume we have that method parseDate() creating a
								<reference class="java.sql.Date"/> for us. 
								Then we'll continue adding the GROUP BY clause
							</p>
							<pre class="prettyprint lang-java">
SelectHavingStep groupBy(Field&lt;?&gt;... fields);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(TBook.AUTHOR_ID.equal(TAuthor.ID))
      .where(TBook.LANGUAGE.equal("DE"))
      .and(TBook.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(TAuthor.FIRST_NAME, TAuthor.LAST_NAME);</pre>
      
      						<p>and the HAVING clause: </p>
      						<pre class="prettyprint lang-java">
SelectOrderByStep having(Condition... conditions);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(TBook.AUTHOR_ID.equal(TAuthor.ID))
      .where(TBook.LANGUAGE.equal("DE"))
      .and(TBook.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .having(create.count().greaterThan(5));</pre>

							<p>and the ORDER BY clause. Some RDBMS support NULLS FIRST and NULLS
								LAST extensions to the ORDER BY clause. If this is not supported by
								the RDBMS, then the behaviour is simulated with an additional CASE
								WHEN ... IS NULL THEN 1 ELSE 0 END clause. </p>
							<pre class="prettyprint lang-java">
SelectLimitStep orderBy(Field&lt;?&gt;... fields);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(TBook.AUTHOR_ID.equal(TAuthor.ID))
      .where(TBook.LANGUAGE.equal("DE"))
      .and(TBook.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .having(create.count().greaterThan(5))
      .orderBy(TAuthor.LAST_NAME.asc().nullsFirst());</pre>

							<p>and finally the LIMIT clause. Most dialects have a means of limiting
								the number of result records (except Oracle). Some even support having
								an OFFSET to the LIMIT clause. Even if your RDBMS does not support the
								full LIMIT ... OFFSET ... clause, jOOQ
								will simulate the LIMIT clause using nested selects and filtering on
								ROWNUM (for Oracle), or on ROW_NUMBER() (for DB2 and SQL
								Server): </p>
							<pre class="prettyprint lang-java">
SelectFinalStep limit(int offset, int numberOfRows);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(TBook.AUTHOR_ID.equal(TAuthor.ID))
      .where(TBook.LANGUAGE.equal("DE"))
      .and(TBook.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .having(create.count().greaterThan(5))
      .orderBy(TAuthor.LAST_NAME.asc().nullsFirst())
      .limit(1, 2);</pre>

							<p>In the final step, there are some proprietary extensions available
								only in some RDBMS. One of those extensions are the FOR UPDATE
								(supported in most RDBMS) and FOR SHARE clauses (supported only in
								MySQL and Postgres): </p>
							<pre class="prettyprint lang-java">
SelectFinalStep forUpdate();

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, create.count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(TBook.AUTHOR_ID.equal(TAuthor.ID))
      .where(TBook.LANGUAGE.equal("DE"))
      .and(TBook.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(TAuthor.FIRST_NAME, TAuthor.LAST_NAME)
      .having(create.count().greaterThan(5))
      .orderBy(TAuthor.LAST_NAME.asc().nullsFirst())
      .limit(1, 2)
      .forUpdate();</pre>

							<p>
								Now the most relevant super-type of the object we have just created is 
								<reference class="org.jooq.Select"/>&lt;Record&gt;. 
								This type can be reused in various expressions such as in the
								<reference id="UNION" title="UNION and other set operations"/>, 
								<reference id="EXISTS" title="Nested select statements using the EXISTS operator"/>, 
								etc. If you just want to execute this select
								statement, you can choose any of these methods as discussed in the 
								section about the <reference id="ResultQuery" title="ResultQuery"/>:
							</p>
							
							<pre class="prettyprint lang-java">
// Just execute the query.
int execute() throws SQLException;

// Execute the query and retrieve the results
Result&lt;Record&gt; fetch() throws SQLException;

// Execute the query and retrieve the first Record
Record fetchAny() throws SQLException;

// Execute the query and retrieve the single Record
// An Exception is thrown if more records were available
Record fetchOne() throws SQLException;

// [...]</pre>


							<h2>SELECT from single physical tables</h2>
							<p>A very similar API is available, if you want to select from single
								physical tables in order to retrieve TableRecords or even
								UpdatableRecords (see also the manual's section on 
								<reference id="Query" title="SelectQuery vs SimpleSelectQuery"/>). 
								The decision, which type of select to create is
								already made at the very first step, when you create the SELECT
								statement with the Factory: </p>
								
							<pre class="prettyprint lang-java">public &lt;R extends Record&gt; SimpleSelectWhereStep&lt;R&gt; selectFrom(Table&lt;R&gt; table);</pre>
							<p>As you can see, there is no way to further restrict/project the selected
								fields. This just selects all known TableFields in the supplied Table,
								and it also binds &lt;R extends Record&gt; to your Table's associated
								Record. An example of such a Query would then be: </p>
							<pre class="prettyprint lang-java">
TBook book = create.selectFrom(T_BOOK)
                   .where(TBook.LANGUAGE.equal("DE"))
                   .orderBy(TBook.TITLE)
                   .fetchAny();</pre>
						</content>
					</section>
					
					
					<section id="CONDITION">
						<title>Conditions</title>
					</section>
					
					
					<section id="ALIAS">
						<title>Aliased tables and fields</title>
					</section>
					
					
					<section id="IN">
						<title>Nested select statements using the IN operator</title>
					</section>
					
					
					<section id="EXISTS">
						<title>Nested select statements using the EXISTS operator</title>
					</section>
					
					
					<section id="NESTED">
						<title>Other types of nested selects</title>
					</section>
					
					
					<section id="UNION">
						<title>UNION and other set operations</title>
					</section>
					
					
					<section id="FUNCTIONS">
						<title>Functions, aggregate operators, and window functions</title>
					</section>
					
					
					<section id="PROCEDURES">
						<title>Stored procedures and functions</title>
					</section>
					
					
					<section id="ARITHMETIC">
						<title>Arithmetic operations</title>
					</section>
					
					
					<section id="CASE">
						<title>The CASE clause</title>
					</section>
					
					
					<section id="CAST">
						<title>Type casting</title>
					</section>
					
					
					<section id="SQL">
						<title>When it's just much easier: Plain SQL</title>
					</section>
				</sections>
			</section>
			<section id="ADVANCED">
				<title>Advanced topics</title>
				<sections>
					<section id="MasterData">
						<title>Master data generation</title>
					</section>
					<section id="SchemaMapping">
						<title>Mapping generated schemata and tables to productive environments</title>
					</section>
					<section id="OracleHints">
						<title>Adding Oracle hints to queries</title>
					</section>
					<section id="CONNECTBY">
						<title>The Oracle CONNECT BY clause for hierarchical queries</title>
					</section>
					<section id="Export">
						<title>Exporting data to XML, CSV, JSON, HTML, Text</title>
					</section>
					<section id="Import">
						<title>Importing data from XML, CSV</title>
					</section>
				</sections>
			</section>
		</sections>
	</section>
</manual>